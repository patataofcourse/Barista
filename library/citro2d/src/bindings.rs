/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: u8 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u8 = 4;
pub const __NEWLIB_MINOR__: u8 = 2;
pub const __NEWLIB_PATCHLEVEL__: u8 = 0;
pub const _DEFAULT_SOURCE: u8 = 1;
pub const _POSIX_SOURCE: u8 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u8 = 1;
pub const __ATFILE_VISIBLE: u8 = 1;
pub const __BSD_VISIBLE: u8 = 1;
pub const __GNU_VISIBLE: u8 = 0;
pub const __ISO_C_VISIBLE: u16 = 2011;
pub const __LARGEFILE_VISIBLE: u8 = 0;
pub const __MISC_VISIBLE: u8 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u8 = 1;
pub const __XSI_VISIBLE: u8 = 0;
pub const __SSP_FORTIFY_LEVEL: u8 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u8 = 1;
pub const __have_longlong64: u8 = 1;
pub const __have_long32: u8 = 1;
pub const ___int8_t_defined: u8 = 1;
pub const ___int16_t_defined: u8 = 1;
pub const ___int32_t_defined: u8 = 1;
pub const ___int64_t_defined: u8 = 1;
pub const ___int_least8_t_defined: u8 = 1;
pub const ___int_least16_t_defined: u8 = 1;
pub const ___int_least32_t_defined: u8 = 1;
pub const ___int_least64_t_defined: u8 = 1;
pub const __int20: u8 = 2;
pub const __int20__: u8 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u8 = 1;
pub const __int16_t_defined: u8 = 1;
pub const __int32_t_defined: u8 = 1;
pub const __int64_t_defined: u8 = 1;
pub const __int_least8_t_defined: u8 = 1;
pub const __int_least16_t_defined: u8 = 1;
pub const __int_least32_t_defined: u8 = 1;
pub const __int_least64_t_defined: u8 = 1;
pub const __int_fast8_t_defined: u8 = 1;
pub const __int_fast16_t_defined: u8 = 1;
pub const __int_fast32_t_defined: u8 = 1;
pub const __int_fast64_t_defined: u8 = 1;
pub const WINT_MIN: u8 = 0;
pub const __bool_true_false_are_defined: u8 = 1;
pub const true_: u8 = 1;
pub const false_: u8 = 0;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: i8 = -1;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const SYSCLOCK_SOC: u32 = 16756991;
pub const SYSCLOCK_SYS: u32 = 33513982;
pub const SYSCLOCK_SDMMC: u32 = 67027964;
pub const SYSCLOCK_ARM9: u32 = 134055928;
pub const SYSCLOCK_ARM11: u32 = 268111856;
pub const SYSCLOCK_ARM11_LGR1: u32 = 536223712;
pub const SYSCLOCK_ARM11_LGR2: u32 = 804335568;
pub const SYSCLOCK_ARM11_NEW: u32 = 804335568;
pub const CPU_TICKS_PER_MSEC: f64 = 268111.856;
pub const CPU_TICKS_PER_USEC: f64 = 268.111856;
pub const OS_HEAP_AREA_BEGIN: u32 = 134217728;
pub const OS_HEAP_AREA_END: u32 = 234881024;
pub const OS_MAP_AREA_BEGIN: u32 = 268435456;
pub const OS_MAP_AREA_END: u32 = 335544320;
pub const OS_OLD_FCRAM_VADDR: u32 = 335544320;
pub const OS_OLD_FCRAM_PADDR: u32 = 536870912;
pub const OS_OLD_FCRAM_SIZE: u32 = 134217728;
pub const OS_QTMRAM_VADDR: u32 = 511705088;
pub const OS_QTMRAM_PADDR: u32 = 520093696;
pub const OS_QTMRAM_SIZE: u32 = 4194304;
pub const OS_MMIO_VADDR: u32 = 515899392;
pub const OS_MMIO_PADDR: u32 = 269484032;
pub const OS_MMIO_SIZE: u32 = 4194304;
pub const OS_VRAM_VADDR: u32 = 520093696;
pub const OS_VRAM_PADDR: u32 = 402653184;
pub const OS_VRAM_SIZE: u32 = 6291456;
pub const OS_DSPRAM_VADDR: u32 = 535822336;
pub const OS_DSPRAM_PADDR: u32 = 535822336;
pub const OS_DSPRAM_SIZE: u32 = 524288;
pub const OS_KERNELCFG_VADDR: u32 = 536346624;
pub const OS_SHAREDCFG_VADDR: u32 = 536350720;
pub const OS_FCRAM_VADDR: u32 = 805306368;
pub const OS_FCRAM_PADDR: u32 = 536870912;
pub const OS_FCRAM_SIZE: u32 = 268435456;
pub const __NEWLIB_H__: u8 = 1;
pub const _WANT_IO_C99_FORMATS: u8 = 1;
pub const _WANT_IO_LONG_LONG: u8 = 1;
pub const _WANT_IO_POS_ARGS: u8 = 1;
pub const _REENT_CHECK_VERIFY: u8 = 1;
pub const _MB_CAPABLE: u8 = 1;
pub const _MB_LEN_MAX: u8 = 8;
pub const HAVE_INITFINI_ARRAY: u8 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u8 = 1;
pub const _HAVE_LONG_DOUBLE: u8 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u8 = 1;
pub const _LDBL_EQ_DBL: u8 = 1;
pub const _FVWRITE_IN_STREAMIO: u8 = 1;
pub const _FSEEK_OPTIMIZATION: u8 = 1;
pub const _UNBUF_STREAM_OPT: u8 = 1;
pub const _WANT_USE_GDTOA: u8 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u8 = 0;
pub const __OBSOLETE_MATH: u8 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const GSP_SCREEN_TOP: u8 = 0;
pub const GSP_SCREEN_BOTTOM: u8 = 1;
pub const GSP_SCREEN_WIDTH: u8 = 240;
pub const GSP_SCREEN_HEIGHT_TOP: u16 = 400;
pub const GSP_SCREEN_HEIGHT_TOP_2X: u16 = 800;
pub const GSP_SCREEN_HEIGHT_BOTTOM: u16 = 320;
pub const CONSOLE_COLOR_BOLD: u8 = 1;
pub const CONSOLE_COLOR_FAINT: u8 = 2;
pub const CONSOLE_ITALIC: u8 = 4;
pub const CONSOLE_UNDERLINE: u8 = 8;
pub const CONSOLE_BLINK_SLOW: u8 = 16;
pub const CONSOLE_BLINK_FAST: u8 = 32;
pub const CONSOLE_COLOR_REVERSE: u8 = 64;
pub const CONSOLE_CONCEAL: u8 = 128;
pub const CONSOLE_CROSSED_OUT: u16 = 256;
pub const CONSOLE_FG_CUSTOM: u16 = 512;
pub const CONSOLE_BG_CUSTOM: u16 = 1024;
pub const __GNUCLIKE_ASM: u8 = 3;
pub const __GNUCLIKE___TYPEOF: u8 = 1;
pub const __GNUCLIKE___OFFSETOF: u8 = 1;
pub const __GNUCLIKE___SECTION: u8 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u8 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u8 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u8 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u8 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u8 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u8 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u8 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u8 = 1;
pub const __CC_SUPPORTS_INLINE: u8 = 1;
pub const __CC_SUPPORTS___INLINE: u8 = 1;
pub const __CC_SUPPORTS___INLINE__: u8 = 1;
pub const __CC_SUPPORTS___FUNC__: u8 = 1;
pub const __CC_SUPPORTS_WARNING: u8 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u8 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u8 = 1;
pub const __BIT_TYPES_DEFINED__: u8 = 1;
pub const _LITTLE_ENDIAN: u16 = 1234;
pub const _BIG_ENDIAN: u16 = 4321;
pub const _PDP_ENDIAN: u16 = 3412;
pub const _BYTE_ORDER: u16 = 1234;
pub const _QUAD_HIGHWORD: u8 = 1;
pub const _QUAD_LOWWORD: u8 = 0;
pub const LITTLE_ENDIAN: u16 = 1234;
pub const BIG_ENDIAN: u16 = 4321;
pub const PDP_ENDIAN: u16 = 3412;
pub const BYTE_ORDER: u16 = 1234;
pub const FD_SETSIZE: u8 = 64;
pub const SCHED_OTHER: u8 = 0;
pub const SCHED_FIFO: u8 = 1;
pub const SCHED_RR: u8 = 2;
pub const PTHREAD_SCOPE_PROCESS: u8 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u8 = 1;
pub const PTHREAD_INHERIT_SCHED: u8 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u8 = 2;
pub const PTHREAD_CREATE_DETACHED: u8 = 0;
pub const PTHREAD_CREATE_JOINABLE: u8 = 1;
pub const CSND_NUM_CHANNELS: u8 = 32;
pub const FRIEND_SCREEN_NAME_SIZE: u8 = 11;
pub const FRIEND_COMMENT_SIZE: u8 = 33;
pub const FRIEND_LIST_SIZE: u8 = 100;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: u32 = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: u32 = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: u32 = 3626016873;
pub const UDS_MAXNODES: u8 = 16;
pub const UDS_BROADCAST_NETWORKNODEID: u16 = 65535;
pub const UDS_HOST_NETWORKNODEID: u8 = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: u16 = 11824;
pub const UDS_DATAFRAME_MAXSIZE: u16 = 1478;
pub const DST_NONE: u8 = 0;
pub const DST_USA: u8 = 1;
pub const DST_AUST: u8 = 2;
pub const DST_WET: u8 = 3;
pub const DST_MET: u8 = 4;
pub const DST_EET: u8 = 5;
pub const DST_CAN: u8 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u8 = 0;
pub const ITIMER_VIRTUAL: u8 = 1;
pub const ITIMER_PROF: u8 = 2;
pub const _NULL: u8 = 0;
pub const _ATEXIT_SIZE: u8 = 32;
pub const _RAND48_SEED_0: u16 = 13070;
pub const _RAND48_SEED_1: u16 = 43981;
pub const _RAND48_SEED_2: u16 = 4660;
pub const _RAND48_MULT_0: u16 = 58989;
pub const _RAND48_MULT_1: u16 = 57068;
pub const _RAND48_MULT_2: u8 = 5;
pub const _RAND48_ADD: u8 = 11;
pub const _REENT_EMERGENCY_SIZE: u8 = 25;
pub const _REENT_ASCTIME_SIZE: u8 = 26;
pub const _REENT_SIGNAL_SIZE: u8 = 24;
pub const _N_LISTS: u8 = 30;
pub const _CLOCKS_PER_SEC_: u8 = 100;
pub const CLOCKS_PER_SEC: u8 = 100;
pub const CLK_TCK: u8 = 100;
pub const SIGEV_NONE: u8 = 1;
pub const SIGEV_SIGNAL: u8 = 2;
pub const SIGEV_THREAD: u8 = 3;
pub const SI_USER: u8 = 1;
pub const SI_QUEUE: u8 = 2;
pub const SI_TIMER: u8 = 3;
pub const SI_ASYNCIO: u8 = 4;
pub const SI_MESGQ: u8 = 5;
pub const SA_NOCLDSTOP: u8 = 1;
pub const MINSIGSTKSZ: u16 = 2048;
pub const SIGSTKSZ: u16 = 8192;
pub const SS_ONSTACK: u8 = 1;
pub const SS_DISABLE: u8 = 2;
pub const SIG_SETMASK: u8 = 0;
pub const SIG_BLOCK: u8 = 1;
pub const SIG_UNBLOCK: u8 = 2;
pub const SIGHUP: u8 = 1;
pub const SIGINT: u8 = 2;
pub const SIGQUIT: u8 = 3;
pub const SIGILL: u8 = 4;
pub const SIGTRAP: u8 = 5;
pub const SIGIOT: u8 = 6;
pub const SIGABRT: u8 = 6;
pub const SIGEMT: u8 = 7;
pub const SIGFPE: u8 = 8;
pub const SIGKILL: u8 = 9;
pub const SIGBUS: u8 = 10;
pub const SIGSEGV: u8 = 11;
pub const SIGSYS: u8 = 12;
pub const SIGPIPE: u8 = 13;
pub const SIGALRM: u8 = 14;
pub const SIGTERM: u8 = 15;
pub const SIGURG: u8 = 16;
pub const SIGSTOP: u8 = 17;
pub const SIGTSTP: u8 = 18;
pub const SIGCONT: u8 = 19;
pub const SIGCHLD: u8 = 20;
pub const SIGCLD: u8 = 20;
pub const SIGTTIN: u8 = 21;
pub const SIGTTOU: u8 = 22;
pub const SIGIO: u8 = 23;
pub const SIGPOLL: u8 = 23;
pub const SIGXCPU: u8 = 24;
pub const SIGXFSZ: u8 = 25;
pub const SIGVTALRM: u8 = 26;
pub const SIGPROF: u8 = 27;
pub const SIGWINCH: u8 = 28;
pub const SIGLOST: u8 = 29;
pub const SIGUSR1: u8 = 30;
pub const SIGUSR2: u8 = 31;
pub const NSIG: u8 = 32;
pub const CLOCK_ENABLED: u8 = 1;
pub const CLOCK_DISABLED: u8 = 0;
pub const CLOCK_ALLOWED: u8 = 1;
pub const CLOCK_DISALLOWED: u8 = 0;
pub const TIMER_ABSTIME: u8 = 4;
pub const SOL_SOCKET: u16 = 65535;
pub const PF_UNSPEC: u8 = 0;
pub const PF_INET: u8 = 2;
pub const PF_INET6: u8 = 23;
pub const AF_UNSPEC: u8 = 0;
pub const AF_INET: u8 = 2;
pub const AF_INET6: u8 = 23;
pub const SOCK_STREAM: u8 = 1;
pub const SOCK_DGRAM: u8 = 2;
pub const MSG_OOB: u8 = 1;
pub const MSG_PEEK: u8 = 2;
pub const MSG_DONTWAIT: u8 = 4;
pub const MSG_DONTROUTE: u8 = 0;
pub const MSG_WAITALL: u8 = 0;
pub const MSG_MORE: u8 = 0;
pub const MSG_NOSIGNAL: u8 = 0;
pub const SHUT_RD: u8 = 0;
pub const SHUT_WR: u8 = 1;
pub const SHUT_RDWR: u8 = 2;
pub const SO_REUSEADDR: u8 = 4;
pub const SO_LINGER: u8 = 128;
pub const SO_OOBINLINE: u16 = 256;
pub const SO_SNDBUF: u16 = 4097;
pub const SO_RCVBUF: u16 = 4098;
pub const SO_SNDLOWAT: u16 = 4099;
pub const SO_RCVLOWAT: u16 = 4100;
pub const SO_TYPE: u16 = 4104;
pub const SO_ERROR: u16 = 4105;
pub const SO_BROADCAST: u8 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_ANY: u8 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u8 = 16;
pub const IPPROTO_IP: u8 = 0;
pub const IPPROTO_UDP: u8 = 17;
pub const IPPROTO_TCP: u8 = 6;
pub const IP_TOS: u8 = 7;
pub const IP_TTL: u8 = 8;
pub const IP_MULTICAST_LOOP: u8 = 9;
pub const IP_MULTICAST_TTL: u8 = 10;
pub const IP_ADD_MEMBERSHIP: u8 = 11;
pub const IP_DROP_MEMBERSHIP: u8 = 12;
pub const SOL_CONFIG: u16 = 65534;
pub const ROUTING_FLAG_G: u8 = 1;
pub const TCP_STATE_CLOSED: u8 = 1;
pub const TCP_STATE_LISTEN: u8 = 2;
pub const TCP_STATE_ESTABLISHED: u8 = 5;
pub const TCP_STATE_FINWAIT1: u8 = 6;
pub const TCP_STATE_FINWAIT2: u8 = 7;
pub const TCP_STATE_CLOSE_WAIT: u8 = 8;
pub const TCP_STATE_LAST_ACK: u8 = 9;
pub const TCP_STATE_TIME_WAIT: u8 = 11;
pub const MVD_STATUS_OK: u32 = 94208;
pub const MVD_STATUS_PARAMSET: u32 = 94209;
pub const MVD_STATUS_BUSY: u32 = 94210;
pub const MVD_STATUS_FRAMEREADY: u32 = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: u32 = 94212;
pub const MVD_STATUS_NALUPROCFLAG: u32 = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: u32 = 9438920;
pub const NFC_ERR_INVALID_STATE: u32 = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: u32 = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: u32 = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: u32 = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: u32 = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: u32 = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: u8 = 0;
pub const GPUREG_0000: u8 = 0;
pub const GPUREG_0001: u8 = 1;
pub const GPUREG_0002: u8 = 2;
pub const GPUREG_0003: u8 = 3;
pub const GPUREG_0004: u8 = 4;
pub const GPUREG_0005: u8 = 5;
pub const GPUREG_0006: u8 = 6;
pub const GPUREG_0007: u8 = 7;
pub const GPUREG_0008: u8 = 8;
pub const GPUREG_0009: u8 = 9;
pub const GPUREG_000A: u8 = 10;
pub const GPUREG_000B: u8 = 11;
pub const GPUREG_000C: u8 = 12;
pub const GPUREG_000D: u8 = 13;
pub const GPUREG_000E: u8 = 14;
pub const GPUREG_000F: u8 = 15;
pub const GPUREG_FINALIZE: u8 = 16;
pub const GPUREG_0011: u8 = 17;
pub const GPUREG_0012: u8 = 18;
pub const GPUREG_0013: u8 = 19;
pub const GPUREG_0014: u8 = 20;
pub const GPUREG_0015: u8 = 21;
pub const GPUREG_0016: u8 = 22;
pub const GPUREG_0017: u8 = 23;
pub const GPUREG_0018: u8 = 24;
pub const GPUREG_0019: u8 = 25;
pub const GPUREG_001A: u8 = 26;
pub const GPUREG_001B: u8 = 27;
pub const GPUREG_001C: u8 = 28;
pub const GPUREG_001D: u8 = 29;
pub const GPUREG_001E: u8 = 30;
pub const GPUREG_001F: u8 = 31;
pub const GPUREG_0020: u8 = 32;
pub const GPUREG_0021: u8 = 33;
pub const GPUREG_0022: u8 = 34;
pub const GPUREG_0023: u8 = 35;
pub const GPUREG_0024: u8 = 36;
pub const GPUREG_0025: u8 = 37;
pub const GPUREG_0026: u8 = 38;
pub const GPUREG_0027: u8 = 39;
pub const GPUREG_0028: u8 = 40;
pub const GPUREG_0029: u8 = 41;
pub const GPUREG_002A: u8 = 42;
pub const GPUREG_002B: u8 = 43;
pub const GPUREG_002C: u8 = 44;
pub const GPUREG_002D: u8 = 45;
pub const GPUREG_002E: u8 = 46;
pub const GPUREG_002F: u8 = 47;
pub const GPUREG_0030: u8 = 48;
pub const GPUREG_0031: u8 = 49;
pub const GPUREG_0032: u8 = 50;
pub const GPUREG_0033: u8 = 51;
pub const GPUREG_0034: u8 = 52;
pub const GPUREG_0035: u8 = 53;
pub const GPUREG_0036: u8 = 54;
pub const GPUREG_0037: u8 = 55;
pub const GPUREG_0038: u8 = 56;
pub const GPUREG_0039: u8 = 57;
pub const GPUREG_003A: u8 = 58;
pub const GPUREG_003B: u8 = 59;
pub const GPUREG_003C: u8 = 60;
pub const GPUREG_003D: u8 = 61;
pub const GPUREG_003E: u8 = 62;
pub const GPUREG_003F: u8 = 63;
pub const GPUREG_FACECULLING_CONFIG: u8 = 64;
pub const GPUREG_VIEWPORT_WIDTH: u8 = 65;
pub const GPUREG_VIEWPORT_INVW: u8 = 66;
pub const GPUREG_VIEWPORT_HEIGHT: u8 = 67;
pub const GPUREG_VIEWPORT_INVH: u8 = 68;
pub const GPUREG_0045: u8 = 69;
pub const GPUREG_0046: u8 = 70;
pub const GPUREG_FRAGOP_CLIP: u8 = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: u8 = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: u8 = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: u8 = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: u8 = 75;
pub const GPUREG_004C: u8 = 76;
pub const GPUREG_DEPTHMAP_SCALE: u8 = 77;
pub const GPUREG_DEPTHMAP_OFFSET: u8 = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: u8 = 79;
pub const GPUREG_SH_OUTMAP_O0: u8 = 80;
pub const GPUREG_SH_OUTMAP_O1: u8 = 81;
pub const GPUREG_SH_OUTMAP_O2: u8 = 82;
pub const GPUREG_SH_OUTMAP_O3: u8 = 83;
pub const GPUREG_SH_OUTMAP_O4: u8 = 84;
pub const GPUREG_SH_OUTMAP_O5: u8 = 85;
pub const GPUREG_SH_OUTMAP_O6: u8 = 86;
pub const GPUREG_0057: u8 = 87;
pub const GPUREG_0058: u8 = 88;
pub const GPUREG_0059: u8 = 89;
pub const GPUREG_005A: u8 = 90;
pub const GPUREG_005B: u8 = 91;
pub const GPUREG_005C: u8 = 92;
pub const GPUREG_005D: u8 = 93;
pub const GPUREG_005E: u8 = 94;
pub const GPUREG_005F: u8 = 95;
pub const GPUREG_0060: u8 = 96;
pub const GPUREG_EARLYDEPTH_FUNC: u8 = 97;
pub const GPUREG_EARLYDEPTH_TEST1: u8 = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: u8 = 99;
pub const GPUREG_SH_OUTATTR_MODE: u8 = 100;
pub const GPUREG_SCISSORTEST_MODE: u8 = 101;
pub const GPUREG_SCISSORTEST_POS: u8 = 102;
pub const GPUREG_SCISSORTEST_DIM: u8 = 103;
pub const GPUREG_VIEWPORT_XY: u8 = 104;
pub const GPUREG_0069: u8 = 105;
pub const GPUREG_EARLYDEPTH_DATA: u8 = 106;
pub const GPUREG_006B: u8 = 107;
pub const GPUREG_006C: u8 = 108;
pub const GPUREG_DEPTHMAP_ENABLE: u8 = 109;
pub const GPUREG_RENDERBUF_DIM: u8 = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: u8 = 111;
pub const GPUREG_0070: u8 = 112;
pub const GPUREG_0071: u8 = 113;
pub const GPUREG_0072: u8 = 114;
pub const GPUREG_0073: u8 = 115;
pub const GPUREG_0074: u8 = 116;
pub const GPUREG_0075: u8 = 117;
pub const GPUREG_0076: u8 = 118;
pub const GPUREG_0077: u8 = 119;
pub const GPUREG_0078: u8 = 120;
pub const GPUREG_0079: u8 = 121;
pub const GPUREG_007A: u8 = 122;
pub const GPUREG_007B: u8 = 123;
pub const GPUREG_007C: u8 = 124;
pub const GPUREG_007D: u8 = 125;
pub const GPUREG_007E: u8 = 126;
pub const GPUREG_007F: u8 = 127;
pub const GPUREG_TEXUNIT_CONFIG: u8 = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: u8 = 129;
pub const GPUREG_TEXUNIT0_DIM: u8 = 130;
pub const GPUREG_TEXUNIT0_PARAM: u8 = 131;
pub const GPUREG_TEXUNIT0_LOD: u8 = 132;
pub const GPUREG_TEXUNIT0_ADDR1: u8 = 133;
pub const GPUREG_TEXUNIT0_ADDR2: u8 = 134;
pub const GPUREG_TEXUNIT0_ADDR3: u8 = 135;
pub const GPUREG_TEXUNIT0_ADDR4: u8 = 136;
pub const GPUREG_TEXUNIT0_ADDR5: u8 = 137;
pub const GPUREG_TEXUNIT0_ADDR6: u8 = 138;
pub const GPUREG_TEXUNIT0_SHADOW: u8 = 139;
pub const GPUREG_008C: u8 = 140;
pub const GPUREG_008D: u8 = 141;
pub const GPUREG_TEXUNIT0_TYPE: u8 = 142;
pub const GPUREG_LIGHTING_ENABLE0: u8 = 143;
pub const GPUREG_0090: u8 = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: u8 = 145;
pub const GPUREG_TEXUNIT1_DIM: u8 = 146;
pub const GPUREG_TEXUNIT1_PARAM: u8 = 147;
pub const GPUREG_TEXUNIT1_LOD: u8 = 148;
pub const GPUREG_TEXUNIT1_ADDR: u8 = 149;
pub const GPUREG_TEXUNIT1_TYPE: u8 = 150;
pub const GPUREG_0097: u8 = 151;
pub const GPUREG_0098: u8 = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: u8 = 153;
pub const GPUREG_TEXUNIT2_DIM: u8 = 154;
pub const GPUREG_TEXUNIT2_PARAM: u8 = 155;
pub const GPUREG_TEXUNIT2_LOD: u8 = 156;
pub const GPUREG_TEXUNIT2_ADDR: u8 = 157;
pub const GPUREG_TEXUNIT2_TYPE: u8 = 158;
pub const GPUREG_009F: u8 = 159;
pub const GPUREG_00A0: u8 = 160;
pub const GPUREG_00A1: u8 = 161;
pub const GPUREG_00A2: u8 = 162;
pub const GPUREG_00A3: u8 = 163;
pub const GPUREG_00A4: u8 = 164;
pub const GPUREG_00A5: u8 = 165;
pub const GPUREG_00A6: u8 = 166;
pub const GPUREG_00A7: u8 = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: u8 = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: u8 = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: u8 = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: u8 = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: u8 = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: u8 = 13;
pub const GPUREG_00AE: u8 = 174;
pub const GPUREG_PROCTEX_LUT: u8 = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: u8 = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: u8 = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: u8 = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: u8 = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: u8 = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: u8 = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: u8 = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: u8 = 183;
pub const GPUREG_00B8: u8 = 184;
pub const GPUREG_00B9: u8 = 185;
pub const GPUREG_00BA: u8 = 186;
pub const GPUREG_00BB: u8 = 187;
pub const GPUREG_00BC: u8 = 188;
pub const GPUREG_00BD: u8 = 189;
pub const GPUREG_00BE: u8 = 190;
pub const GPUREG_00BF: u8 = 191;
pub const GPUREG_TEXENV0_SOURCE: u8 = 192;
pub const GPUREG_TEXENV0_OPERAND: u8 = 193;
pub const GPUREG_TEXENV0_COMBINER: u8 = 194;
pub const GPUREG_TEXENV0_COLOR: u8 = 195;
pub const GPUREG_TEXENV0_SCALE: u8 = 196;
pub const GPUREG_00C5: u8 = 197;
pub const GPUREG_00C6: u8 = 198;
pub const GPUREG_00C7: u8 = 199;
pub const GPUREG_TEXENV1_SOURCE: u8 = 200;
pub const GPUREG_TEXENV1_OPERAND: u8 = 201;
pub const GPUREG_TEXENV1_COMBINER: u8 = 202;
pub const GPUREG_TEXENV1_COLOR: u8 = 203;
pub const GPUREG_TEXENV1_SCALE: u8 = 204;
pub const GPUREG_00CD: u8 = 205;
pub const GPUREG_00CE: u8 = 206;
pub const GPUREG_00CF: u8 = 207;
pub const GPUREG_TEXENV2_SOURCE: u8 = 208;
pub const GPUREG_TEXENV2_OPERAND: u8 = 209;
pub const GPUREG_TEXENV2_COMBINER: u8 = 210;
pub const GPUREG_TEXENV2_COLOR: u8 = 211;
pub const GPUREG_TEXENV2_SCALE: u8 = 212;
pub const GPUREG_00D5: u8 = 213;
pub const GPUREG_00D6: u8 = 214;
pub const GPUREG_00D7: u8 = 215;
pub const GPUREG_TEXENV3_SOURCE: u8 = 216;
pub const GPUREG_TEXENV3_OPERAND: u8 = 217;
pub const GPUREG_TEXENV3_COMBINER: u8 = 218;
pub const GPUREG_TEXENV3_COLOR: u8 = 219;
pub const GPUREG_TEXENV3_SCALE: u8 = 220;
pub const GPUREG_00DD: u8 = 221;
pub const GPUREG_00DE: u8 = 222;
pub const GPUREG_00DF: u8 = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: u8 = 224;
pub const GPUREG_FOG_COLOR: u8 = 225;
pub const GPUREG_00E2: u8 = 226;
pub const GPUREG_00E3: u8 = 227;
pub const GPUREG_GAS_ATTENUATION: u8 = 228;
pub const GPUREG_GAS_ACCMAX: u8 = 229;
pub const GPUREG_FOG_LUT_INDEX: u8 = 230;
pub const GPUREG_00E7: u8 = 231;
pub const GPUREG_FOG_LUT_DATA0: u8 = 232;
pub const GPUREG_FOG_LUT_DATA1: u8 = 233;
pub const GPUREG_FOG_LUT_DATA2: u8 = 234;
pub const GPUREG_FOG_LUT_DATA3: u8 = 235;
pub const GPUREG_FOG_LUT_DATA4: u8 = 236;
pub const GPUREG_FOG_LUT_DATA5: u8 = 237;
pub const GPUREG_FOG_LUT_DATA6: u8 = 238;
pub const GPUREG_FOG_LUT_DATA7: u8 = 239;
pub const GPUREG_TEXENV4_SOURCE: u8 = 240;
pub const GPUREG_TEXENV4_OPERAND: u8 = 241;
pub const GPUREG_TEXENV4_COMBINER: u8 = 242;
pub const GPUREG_TEXENV4_COLOR: u8 = 243;
pub const GPUREG_TEXENV4_SCALE: u8 = 244;
pub const GPUREG_00F5: u8 = 245;
pub const GPUREG_00F6: u8 = 246;
pub const GPUREG_00F7: u8 = 247;
pub const GPUREG_TEXENV5_SOURCE: u8 = 248;
pub const GPUREG_TEXENV5_OPERAND: u8 = 249;
pub const GPUREG_TEXENV5_COMBINER: u8 = 250;
pub const GPUREG_TEXENV5_COLOR: u8 = 251;
pub const GPUREG_TEXENV5_SCALE: u8 = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: u8 = 253;
pub const GPUREG_00FE: u8 = 254;
pub const GPUREG_00FF: u8 = 255;
pub const GPUREG_COLOR_OPERATION: u16 = 256;
pub const GPUREG_BLEND_FUNC: u16 = 257;
pub const GPUREG_LOGIC_OP: u16 = 258;
pub const GPUREG_BLEND_COLOR: u16 = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: u16 = 260;
pub const GPUREG_STENCIL_TEST: u16 = 261;
pub const GPUREG_STENCIL_OP: u16 = 262;
pub const GPUREG_DEPTH_COLOR_MASK: u16 = 263;
pub const GPUREG_0108: u16 = 264;
pub const GPUREG_0109: u16 = 265;
pub const GPUREG_010A: u16 = 266;
pub const GPUREG_010B: u16 = 267;
pub const GPUREG_010C: u16 = 268;
pub const GPUREG_010D: u16 = 269;
pub const GPUREG_010E: u16 = 270;
pub const GPUREG_010F: u16 = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: u16 = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: u16 = 273;
pub const GPUREG_COLORBUFFER_READ: u16 = 274;
pub const GPUREG_COLORBUFFER_WRITE: u16 = 275;
pub const GPUREG_DEPTHBUFFER_READ: u16 = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: u16 = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: u16 = 278;
pub const GPUREG_COLORBUFFER_FORMAT: u16 = 279;
pub const GPUREG_EARLYDEPTH_TEST2: u16 = 280;
pub const GPUREG_0119: u16 = 281;
pub const GPUREG_011A: u16 = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: u16 = 283;
pub const GPUREG_DEPTHBUFFER_LOC: u16 = 284;
pub const GPUREG_COLORBUFFER_LOC: u16 = 285;
pub const GPUREG_FRAMEBUFFER_DIM: u16 = 286;
pub const GPUREG_011F: u16 = 287;
pub const GPUREG_GAS_LIGHT_XY: u16 = 288;
pub const GPUREG_GAS_LIGHT_Z: u16 = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: u16 = 290;
pub const GPUREG_GAS_LUT_INDEX: u16 = 291;
pub const GPUREG_GAS_LUT_DATA: u16 = 292;
pub const GPUREG_GAS_ACCMAX_FEEDBACK: u16 = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: u16 = 294;
pub const GPUREG_0127: u16 = 295;
pub const GPUREG_0128: u16 = 296;
pub const GPUREG_0129: u16 = 297;
pub const GPUREG_012A: u16 = 298;
pub const GPUREG_012B: u16 = 299;
pub const GPUREG_012C: u16 = 300;
pub const GPUREG_012D: u16 = 301;
pub const GPUREG_012E: u16 = 302;
pub const GPUREG_012F: u16 = 303;
pub const GPUREG_FRAGOP_SHADOW: u16 = 304;
pub const GPUREG_0131: u16 = 305;
pub const GPUREG_0132: u16 = 306;
pub const GPUREG_0133: u16 = 307;
pub const GPUREG_0134: u16 = 308;
pub const GPUREG_0135: u16 = 309;
pub const GPUREG_0136: u16 = 310;
pub const GPUREG_0137: u16 = 311;
pub const GPUREG_0138: u16 = 312;
pub const GPUREG_0139: u16 = 313;
pub const GPUREG_013A: u16 = 314;
pub const GPUREG_013B: u16 = 315;
pub const GPUREG_013C: u16 = 316;
pub const GPUREG_013D: u16 = 317;
pub const GPUREG_013E: u16 = 318;
pub const GPUREG_013F: u16 = 319;
pub const GPUREG_LIGHT0_SPECULAR0: u16 = 320;
pub const GPUREG_LIGHT0_SPECULAR1: u16 = 321;
pub const GPUREG_LIGHT0_DIFFUSE: u16 = 322;
pub const GPUREG_LIGHT0_AMBIENT: u16 = 323;
pub const GPUREG_LIGHT0_XY: u16 = 324;
pub const GPUREG_LIGHT0_Z: u16 = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: u16 = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: u16 = 327;
pub const GPUREG_0148: u16 = 328;
pub const GPUREG_LIGHT0_CONFIG: u16 = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: u16 = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: u16 = 331;
pub const GPUREG_014C: u16 = 332;
pub const GPUREG_014D: u16 = 333;
pub const GPUREG_014E: u16 = 334;
pub const GPUREG_014F: u16 = 335;
pub const GPUREG_LIGHT1_SPECULAR0: u16 = 336;
pub const GPUREG_LIGHT1_SPECULAR1: u16 = 337;
pub const GPUREG_LIGHT1_DIFFUSE: u16 = 338;
pub const GPUREG_LIGHT1_AMBIENT: u16 = 339;
pub const GPUREG_LIGHT1_XY: u16 = 340;
pub const GPUREG_LIGHT1_Z: u16 = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: u16 = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: u16 = 343;
pub const GPUREG_0158: u16 = 344;
pub const GPUREG_LIGHT1_CONFIG: u16 = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: u16 = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: u16 = 347;
pub const GPUREG_015C: u16 = 348;
pub const GPUREG_015D: u16 = 349;
pub const GPUREG_015E: u16 = 350;
pub const GPUREG_015F: u16 = 351;
pub const GPUREG_LIGHT2_SPECULAR0: u16 = 352;
pub const GPUREG_LIGHT2_SPECULAR1: u16 = 353;
pub const GPUREG_LIGHT2_DIFFUSE: u16 = 354;
pub const GPUREG_LIGHT2_AMBIENT: u16 = 355;
pub const GPUREG_LIGHT2_XY: u16 = 356;
pub const GPUREG_LIGHT2_Z: u16 = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: u16 = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: u16 = 359;
pub const GPUREG_0168: u16 = 360;
pub const GPUREG_LIGHT2_CONFIG: u16 = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: u16 = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: u16 = 363;
pub const GPUREG_016C: u16 = 364;
pub const GPUREG_016D: u16 = 365;
pub const GPUREG_016E: u16 = 366;
pub const GPUREG_016F: u16 = 367;
pub const GPUREG_LIGHT3_SPECULAR0: u16 = 368;
pub const GPUREG_LIGHT3_SPECULAR1: u16 = 369;
pub const GPUREG_LIGHT3_DIFFUSE: u16 = 370;
pub const GPUREG_LIGHT3_AMBIENT: u16 = 371;
pub const GPUREG_LIGHT3_XY: u16 = 372;
pub const GPUREG_LIGHT3_Z: u16 = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: u16 = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: u16 = 375;
pub const GPUREG_0178: u16 = 376;
pub const GPUREG_LIGHT3_CONFIG: u16 = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: u16 = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: u16 = 379;
pub const GPUREG_017C: u16 = 380;
pub const GPUREG_017D: u16 = 381;
pub const GPUREG_017E: u16 = 382;
pub const GPUREG_017F: u16 = 383;
pub const GPUREG_LIGHT4_SPECULAR0: u16 = 384;
pub const GPUREG_LIGHT4_SPECULAR1: u16 = 385;
pub const GPUREG_LIGHT4_DIFFUSE: u16 = 386;
pub const GPUREG_LIGHT4_AMBIENT: u16 = 387;
pub const GPUREG_LIGHT4_XY: u16 = 388;
pub const GPUREG_LIGHT4_Z: u16 = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: u16 = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: u16 = 391;
pub const GPUREG_0188: u16 = 392;
pub const GPUREG_LIGHT4_CONFIG: u16 = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: u16 = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: u16 = 395;
pub const GPUREG_018C: u16 = 396;
pub const GPUREG_018D: u16 = 397;
pub const GPUREG_018E: u16 = 398;
pub const GPUREG_018F: u16 = 399;
pub const GPUREG_LIGHT5_SPECULAR0: u16 = 400;
pub const GPUREG_LIGHT5_SPECULAR1: u16 = 401;
pub const GPUREG_LIGHT5_DIFFUSE: u16 = 402;
pub const GPUREG_LIGHT5_AMBIENT: u16 = 403;
pub const GPUREG_LIGHT5_XY: u16 = 404;
pub const GPUREG_LIGHT5_Z: u16 = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: u16 = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: u16 = 407;
pub const GPUREG_0198: u16 = 408;
pub const GPUREG_LIGHT5_CONFIG: u16 = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: u16 = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: u16 = 411;
pub const GPUREG_019C: u16 = 412;
pub const GPUREG_019D: u16 = 413;
pub const GPUREG_019E: u16 = 414;
pub const GPUREG_019F: u16 = 415;
pub const GPUREG_LIGHT6_SPECULAR0: u16 = 416;
pub const GPUREG_LIGHT6_SPECULAR1: u16 = 417;
pub const GPUREG_LIGHT6_DIFFUSE: u16 = 418;
pub const GPUREG_LIGHT6_AMBIENT: u16 = 419;
pub const GPUREG_LIGHT6_XY: u16 = 420;
pub const GPUREG_LIGHT6_Z: u16 = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: u16 = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: u16 = 423;
pub const GPUREG_01A8: u16 = 424;
pub const GPUREG_LIGHT6_CONFIG: u16 = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: u16 = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: u16 = 427;
pub const GPUREG_01AC: u16 = 428;
pub const GPUREG_01AD: u16 = 429;
pub const GPUREG_01AE: u16 = 430;
pub const GPUREG_01AF: u16 = 431;
pub const GPUREG_LIGHT7_SPECULAR0: u16 = 432;
pub const GPUREG_LIGHT7_SPECULAR1: u16 = 433;
pub const GPUREG_LIGHT7_DIFFUSE: u16 = 434;
pub const GPUREG_LIGHT7_AMBIENT: u16 = 435;
pub const GPUREG_LIGHT7_XY: u16 = 436;
pub const GPUREG_LIGHT7_Z: u16 = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: u16 = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: u16 = 439;
pub const GPUREG_01B8: u16 = 440;
pub const GPUREG_LIGHT7_CONFIG: u16 = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: u16 = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: u16 = 443;
pub const GPUREG_01BC: u16 = 444;
pub const GPUREG_01BD: u16 = 445;
pub const GPUREG_01BE: u16 = 446;
pub const GPUREG_01BF: u16 = 447;
pub const GPUREG_LIGHTING_AMBIENT: u16 = 448;
pub const GPUREG_01C1: u16 = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: u16 = 450;
pub const GPUREG_LIGHTING_CONFIG0: u16 = 451;
pub const GPUREG_LIGHTING_CONFIG1: u16 = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: u16 = 453;
pub const GPUREG_LIGHTING_ENABLE1: u16 = 454;
pub const GPUREG_01C7: u16 = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: u16 = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: u16 = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: u16 = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: u16 = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: u16 = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: u16 = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: u16 = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: u16 = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: u16 = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: u16 = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: u16 = 466;
pub const GPUREG_01D3: u16 = 467;
pub const GPUREG_01D4: u16 = 468;
pub const GPUREG_01D5: u16 = 469;
pub const GPUREG_01D6: u16 = 470;
pub const GPUREG_01D7: u16 = 471;
pub const GPUREG_01D8: u16 = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: u16 = 473;
pub const GPUREG_01DA: u16 = 474;
pub const GPUREG_01DB: u16 = 475;
pub const GPUREG_01DC: u16 = 476;
pub const GPUREG_01DD: u16 = 477;
pub const GPUREG_01DE: u16 = 478;
pub const GPUREG_01DF: u16 = 479;
pub const GPUREG_01E0: u16 = 480;
pub const GPUREG_01E1: u16 = 481;
pub const GPUREG_01E2: u16 = 482;
pub const GPUREG_01E3: u16 = 483;
pub const GPUREG_01E4: u16 = 484;
pub const GPUREG_01E5: u16 = 485;
pub const GPUREG_01E6: u16 = 486;
pub const GPUREG_01E7: u16 = 487;
pub const GPUREG_01E8: u16 = 488;
pub const GPUREG_01E9: u16 = 489;
pub const GPUREG_01EA: u16 = 490;
pub const GPUREG_01EB: u16 = 491;
pub const GPUREG_01EC: u16 = 492;
pub const GPUREG_01ED: u16 = 493;
pub const GPUREG_01EE: u16 = 494;
pub const GPUREG_01EF: u16 = 495;
pub const GPUREG_01F0: u16 = 496;
pub const GPUREG_01F1: u16 = 497;
pub const GPUREG_01F2: u16 = 498;
pub const GPUREG_01F3: u16 = 499;
pub const GPUREG_01F4: u16 = 500;
pub const GPUREG_01F5: u16 = 501;
pub const GPUREG_01F6: u16 = 502;
pub const GPUREG_01F7: u16 = 503;
pub const GPUREG_01F8: u16 = 504;
pub const GPUREG_01F9: u16 = 505;
pub const GPUREG_01FA: u16 = 506;
pub const GPUREG_01FB: u16 = 507;
pub const GPUREG_01FC: u16 = 508;
pub const GPUREG_01FD: u16 = 509;
pub const GPUREG_01FE: u16 = 510;
pub const GPUREG_01FF: u16 = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: u16 = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: u16 = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: u16 = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: u16 = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: u16 = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: u16 = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: u16 = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: u16 = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: u16 = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: u16 = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: u16 = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: u16 = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: u16 = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: u16 = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: u16 = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: u16 = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: u16 = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: u16 = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: u16 = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: u16 = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: u16 = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: u16 = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: u16 = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: u16 = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: u16 = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: u16 = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: u16 = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: u16 = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: u16 = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: u16 = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: u16 = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: u16 = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: u16 = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: u16 = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: u16 = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: u16 = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: u16 = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: u16 = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: u16 = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: u16 = 551;
pub const GPUREG_NUMVERTICES: u16 = 552;
pub const GPUREG_GEOSTAGE_CONFIG: u16 = 553;
pub const GPUREG_VERTEX_OFFSET: u16 = 554;
pub const GPUREG_022B: u16 = 555;
pub const GPUREG_022C: u16 = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: u16 = 557;
pub const GPUREG_DRAWARRAYS: u16 = 558;
pub const GPUREG_DRAWELEMENTS: u16 = 559;
pub const GPUREG_0230: u16 = 560;
pub const GPUREG_VTX_FUNC: u16 = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: u16 = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: u16 = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: u16 = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: u16 = 565;
pub const GPUREG_0236: u16 = 566;
pub const GPUREG_0237: u16 = 567;
pub const GPUREG_CMDBUF_SIZE0: u16 = 568;
pub const GPUREG_CMDBUF_SIZE1: u16 = 569;
pub const GPUREG_CMDBUF_ADDR0: u16 = 570;
pub const GPUREG_CMDBUF_ADDR1: u16 = 571;
pub const GPUREG_CMDBUF_JUMP0: u16 = 572;
pub const GPUREG_CMDBUF_JUMP1: u16 = 573;
pub const GPUREG_023E: u16 = 574;
pub const GPUREG_023F: u16 = 575;
pub const GPUREG_0240: u16 = 576;
pub const GPUREG_0241: u16 = 577;
pub const GPUREG_VSH_NUM_ATTR: u16 = 578;
pub const GPUREG_0243: u16 = 579;
pub const GPUREG_VSH_COM_MODE: u16 = 580;
pub const GPUREG_START_DRAW_FUNC0: u16 = 581;
pub const GPUREG_0246: u16 = 582;
pub const GPUREG_0247: u16 = 583;
pub const GPUREG_0248: u16 = 584;
pub const GPUREG_0249: u16 = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: u16 = 586;
pub const GPUREG_024B: u16 = 587;
pub const GPUREG_024C: u16 = 588;
pub const GPUREG_024D: u16 = 589;
pub const GPUREG_024E: u16 = 590;
pub const GPUREG_024F: u16 = 591;
pub const GPUREG_0250: u16 = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: u16 = 593;
pub const GPUREG_GSH_MISC0: u16 = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: u16 = 595;
pub const GPUREG_GSH_MISC1: u16 = 596;
pub const GPUREG_0255: u16 = 597;
pub const GPUREG_0256: u16 = 598;
pub const GPUREG_0257: u16 = 599;
pub const GPUREG_0258: u16 = 600;
pub const GPUREG_0259: u16 = 601;
pub const GPUREG_025A: u16 = 602;
pub const GPUREG_025B: u16 = 603;
pub const GPUREG_025C: u16 = 604;
pub const GPUREG_025D: u16 = 605;
pub const GPUREG_PRIMITIVE_CONFIG: u16 = 606;
pub const GPUREG_RESTART_PRIMITIVE: u16 = 607;
pub const GPUREG_0260: u16 = 608;
pub const GPUREG_0261: u16 = 609;
pub const GPUREG_0262: u16 = 610;
pub const GPUREG_0263: u16 = 611;
pub const GPUREG_0264: u16 = 612;
pub const GPUREG_0265: u16 = 613;
pub const GPUREG_0266: u16 = 614;
pub const GPUREG_0267: u16 = 615;
pub const GPUREG_0268: u16 = 616;
pub const GPUREG_0269: u16 = 617;
pub const GPUREG_026A: u16 = 618;
pub const GPUREG_026B: u16 = 619;
pub const GPUREG_026C: u16 = 620;
pub const GPUREG_026D: u16 = 621;
pub const GPUREG_026E: u16 = 622;
pub const GPUREG_026F: u16 = 623;
pub const GPUREG_0270: u16 = 624;
pub const GPUREG_0271: u16 = 625;
pub const GPUREG_0272: u16 = 626;
pub const GPUREG_0273: u16 = 627;
pub const GPUREG_0274: u16 = 628;
pub const GPUREG_0275: u16 = 629;
pub const GPUREG_0276: u16 = 630;
pub const GPUREG_0277: u16 = 631;
pub const GPUREG_0278: u16 = 632;
pub const GPUREG_0279: u16 = 633;
pub const GPUREG_027A: u16 = 634;
pub const GPUREG_027B: u16 = 635;
pub const GPUREG_027C: u16 = 636;
pub const GPUREG_027D: u16 = 637;
pub const GPUREG_027E: u16 = 638;
pub const GPUREG_027F: u16 = 639;
pub const GPUREG_GSH_BOOLUNIFORM: u16 = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: u16 = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: u16 = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: u16 = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: u16 = 644;
pub const GPUREG_0285: u16 = 645;
pub const GPUREG_0286: u16 = 646;
pub const GPUREG_0287: u16 = 647;
pub const GPUREG_0288: u16 = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: u16 = 649;
pub const GPUREG_GSH_ENTRYPOINT: u16 = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: u16 = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: u16 = 652;
pub const GPUREG_GSH_OUTMAP_MASK: u16 = 653;
pub const GPUREG_028E: u16 = 654;
pub const GPUREG_GSH_CODETRANSFER_END: u16 = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: u16 = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: u16 = 657;
pub const GPUREG_0299: u16 = 665;
pub const GPUREG_029A: u16 = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: u16 = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: u16 = 668;
pub const GPUREG_02A4: u16 = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: u16 = 677;
pub const GPUREG_GSH_OPDESCS_DATA: u16 = 678;
pub const GPUREG_02AE: u16 = 686;
pub const GPUREG_02AF: u16 = 687;
pub const GPUREG_VSH_BOOLUNIFORM: u16 = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: u16 = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: u16 = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: u16 = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: u16 = 692;
pub const GPUREG_02B5: u16 = 693;
pub const GPUREG_02B6: u16 = 694;
pub const GPUREG_02B7: u16 = 695;
pub const GPUREG_02B8: u16 = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: u16 = 697;
pub const GPUREG_VSH_ENTRYPOINT: u16 = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: u16 = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: u16 = 700;
pub const GPUREG_VSH_OUTMAP_MASK: u16 = 701;
pub const GPUREG_02BE: u16 = 702;
pub const GPUREG_VSH_CODETRANSFER_END: u16 = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: u16 = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: u16 = 705;
pub const GPUREG_02C9: u16 = 713;
pub const GPUREG_02CA: u16 = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: u16 = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: u16 = 716;
pub const GPUREG_02D4: u16 = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: u16 = 725;
pub const GPUREG_VSH_OPDESCS_DATA: u16 = 726;
pub const GPUREG_02DE: u16 = 734;
pub const GPUREG_02DF: u16 = 735;
pub const GPUREG_02E0: u16 = 736;
pub const GPUREG_02E1: u16 = 737;
pub const GPUREG_02E2: u16 = 738;
pub const GPUREG_02E3: u16 = 739;
pub const GPUREG_02E4: u16 = 740;
pub const GPUREG_02E5: u16 = 741;
pub const GPUREG_02E6: u16 = 742;
pub const GPUREG_02E7: u16 = 743;
pub const GPUREG_02E8: u16 = 744;
pub const GPUREG_02E9: u16 = 745;
pub const GPUREG_02EA: u16 = 746;
pub const GPUREG_02EB: u16 = 747;
pub const GPUREG_02EC: u16 = 748;
pub const GPUREG_02ED: u16 = 749;
pub const GPUREG_02EE: u16 = 750;
pub const GPUREG_02EF: u16 = 751;
pub const GPUREG_02F0: u16 = 752;
pub const GPUREG_02F1: u16 = 753;
pub const GPUREG_02F2: u16 = 754;
pub const GPUREG_02F3: u16 = 755;
pub const GPUREG_02F4: u16 = 756;
pub const GPUREG_02F5: u16 = 757;
pub const GPUREG_02F6: u16 = 758;
pub const GPUREG_02F7: u16 = 759;
pub const GPUREG_02F8: u16 = 760;
pub const GPUREG_02F9: u16 = 761;
pub const GPUREG_02FA: u16 = 762;
pub const GPUREG_02FB: u16 = 763;
pub const GPUREG_02FC: u16 = 764;
pub const GPUREG_02FD: u16 = 765;
pub const GPUREG_02FE: u16 = 766;
pub const GPUREG_02FF: u16 = 767;
pub const NDSP_SAMPLE_RATE: f64 = 32728.498046875;
pub const SWKBD_MAX_WORD_LEN: u8 = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: u8 = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: u8 = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: u16 = 256;
pub const MIISELECTOR_MAGIC: u32 = 333326543;
pub const MIISELECTOR_TITLE_LEN: u8 = 64;
pub const MIISELECTOR_GUESTMII_SLOTS: u8 = 6;
pub const MIISELECTOR_USERMII_SLOTS: u8 = 100;
pub const MIISELECTOR_GUESTMII_NAME_LEN: u8 = 12;
pub const ARCHIVE_DIRITER_MAGIC: u32 = 1751347809;
pub const LINK3DS_COMM_PORT: u16 = 17491;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const FP_NAN: u8 = 0;
pub const FP_INFINITE: u8 = 1;
pub const FP_ZERO: u8 = 2;
pub const FP_SUBNORMAL: u8 = 3;
pub const FP_NORMAL: u8 = 4;
pub const MATH_ERRNO: u8 = 1;
pub const MATH_ERREXCEPT: u8 = 2;
pub const _MATH_ERRHANDLING_ERRNO: u8 = 1;
pub const _MATH_ERRHANDLING_ERREXCEPT: u8 = 2;
pub const math_errhandling: u8 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const M_TAU: f64 = 6.283185307179586;
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u8 = 8;
pub const C3D_FVUNIF_COUNT: u8 = 96;
pub const C3D_IVUNIF_COUNT: u8 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub const C3DF_LightEnv_IsCP_Any: u32 = 66846720;
pub const C3DF_LightEnv_LutDirtyAll: u32 = 4227858432;
pub const __GNUC_VA_LIST: u8 = 1;
pub const __SLBF: u8 = 1;
pub const __SNBF: u8 = 2;
pub const __SRD: u8 = 4;
pub const __SWR: u8 = 8;
pub const __SRW: u8 = 16;
pub const __SEOF: u8 = 32;
pub const __SERR: u8 = 64;
pub const __SMBF: u8 = 128;
pub const __SAPP: u16 = 256;
pub const __SSTR: u16 = 512;
pub const __SOPT: u16 = 1024;
pub const __SNPT: u16 = 2048;
pub const __SOFF: u16 = 4096;
pub const __SORD: u16 = 8192;
pub const __SL64: u16 = 32768;
pub const __SNLK: u8 = 1;
pub const __SWID: u16 = 8192;
pub const _IOFBF: u8 = 0;
pub const _IOLBF: u8 = 1;
pub const _IONBF: u8 = 2;
pub const EOF: i8 = -1;
pub const BUFSIZ: u16 = 1024;
pub const FOPEN_MAX: u8 = 20;
pub const FILENAME_MAX: u16 = 1024;
pub const L_tmpnam: u16 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u8 = 0;
pub const SEEK_CUR: u8 = 1;
pub const SEEK_END: u8 = 2;
pub const TMP_MAX: u8 = 26;
pub const L_ctermid: u8 = 16;
pub const C2D_DEFAULT_MAX_OBJECTS: u16 = 4096;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_int;
pub type __uintptr_t = ::libc::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type size_t = ::libc::c_uint;
pub type wchar_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32_;
pub type Result = s32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuRegisters {
    pub r: [u32_; 13usize],
    pub sp: u32_,
    pub lr: u32_,
    pub pc: u32_,
    pub cpsr: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    pub fpscr: u32_,
    pub fpexc: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    pub s: [f32; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    pub d: [f64; 16usize],
}
pub const RL_SUCCESS: ::libc::c_uint = 0;
pub const RL_INFO: ::libc::c_uint = 1;
pub const RL_FATAL: ::libc::c_uint = 31;
pub const RL_RESET: ::libc::c_uint = 30;
pub const RL_REINITIALIZE: ::libc::c_uint = 29;
pub const RL_USAGE: ::libc::c_uint = 28;
pub const RL_PERMANENT: ::libc::c_uint = 27;
pub const RL_TEMPORARY: ::libc::c_uint = 26;
pub const RL_STATUS: ::libc::c_uint = 25;
pub type _bindgen_ty_1 = ::libc::c_uint;
pub const RS_SUCCESS: ::libc::c_uint = 0;
pub const RS_NOP: ::libc::c_uint = 1;
pub const RS_WOULDBLOCK: ::libc::c_uint = 2;
pub const RS_OUTOFRESOURCE: ::libc::c_uint = 3;
pub const RS_NOTFOUND: ::libc::c_uint = 4;
pub const RS_INVALIDSTATE: ::libc::c_uint = 5;
pub const RS_NOTSUPPORTED: ::libc::c_uint = 6;
pub const RS_INVALIDARG: ::libc::c_uint = 7;
pub const RS_WRONGARG: ::libc::c_uint = 8;
pub const RS_CANCELED: ::libc::c_uint = 9;
pub const RS_STATUSCHANGED: ::libc::c_uint = 10;
pub const RS_INTERNAL: ::libc::c_uint = 11;
pub const RS_INVALIDRESVAL: ::libc::c_uint = 63;
pub type _bindgen_ty_2 = ::libc::c_uint;
pub const RM_COMMON: ::libc::c_uint = 0;
pub const RM_KERNEL: ::libc::c_uint = 1;
pub const RM_UTIL: ::libc::c_uint = 2;
pub const RM_FILE_SERVER: ::libc::c_uint = 3;
pub const RM_LOADER_SERVER: ::libc::c_uint = 4;
pub const RM_TCB: ::libc::c_uint = 5;
pub const RM_OS: ::libc::c_uint = 6;
pub const RM_DBG: ::libc::c_uint = 7;
pub const RM_DMNT: ::libc::c_uint = 8;
pub const RM_PDN: ::libc::c_uint = 9;
pub const RM_GSP: ::libc::c_uint = 10;
pub const RM_I2C: ::libc::c_uint = 11;
pub const RM_GPIO: ::libc::c_uint = 12;
pub const RM_DD: ::libc::c_uint = 13;
pub const RM_CODEC: ::libc::c_uint = 14;
pub const RM_SPI: ::libc::c_uint = 15;
pub const RM_PXI: ::libc::c_uint = 16;
pub const RM_FS: ::libc::c_uint = 17;
pub const RM_DI: ::libc::c_uint = 18;
pub const RM_HID: ::libc::c_uint = 19;
pub const RM_CAM: ::libc::c_uint = 20;
pub const RM_PI: ::libc::c_uint = 21;
pub const RM_PM: ::libc::c_uint = 22;
pub const RM_PM_LOW: ::libc::c_uint = 23;
pub const RM_FSI: ::libc::c_uint = 24;
pub const RM_SRV: ::libc::c_uint = 25;
pub const RM_NDM: ::libc::c_uint = 26;
pub const RM_NWM: ::libc::c_uint = 27;
pub const RM_SOC: ::libc::c_uint = 28;
pub const RM_LDR: ::libc::c_uint = 29;
pub const RM_ACC: ::libc::c_uint = 30;
pub const RM_ROMFS: ::libc::c_uint = 31;
pub const RM_AM: ::libc::c_uint = 32;
pub const RM_HIO: ::libc::c_uint = 33;
pub const RM_UPDATER: ::libc::c_uint = 34;
pub const RM_MIC: ::libc::c_uint = 35;
pub const RM_FND: ::libc::c_uint = 36;
pub const RM_MP: ::libc::c_uint = 37;
pub const RM_MPWL: ::libc::c_uint = 38;
pub const RM_AC: ::libc::c_uint = 39;
pub const RM_HTTP: ::libc::c_uint = 40;
pub const RM_DSP: ::libc::c_uint = 41;
pub const RM_SND: ::libc::c_uint = 42;
pub const RM_DLP: ::libc::c_uint = 43;
pub const RM_HIO_LOW: ::libc::c_uint = 44;
pub const RM_CSND: ::libc::c_uint = 45;
pub const RM_SSL: ::libc::c_uint = 46;
pub const RM_AM_LOW: ::libc::c_uint = 47;
pub const RM_NEX: ::libc::c_uint = 48;
pub const RM_FRIENDS: ::libc::c_uint = 49;
pub const RM_RDT: ::libc::c_uint = 50;
pub const RM_APPLET: ::libc::c_uint = 51;
pub const RM_NIM: ::libc::c_uint = 52;
pub const RM_PTM: ::libc::c_uint = 53;
pub const RM_MIDI: ::libc::c_uint = 54;
pub const RM_MC: ::libc::c_uint = 55;
pub const RM_SWC: ::libc::c_uint = 56;
pub const RM_FATFS: ::libc::c_uint = 57;
pub const RM_NGC: ::libc::c_uint = 58;
pub const RM_CARD: ::libc::c_uint = 59;
pub const RM_CARDNOR: ::libc::c_uint = 60;
pub const RM_SDMC: ::libc::c_uint = 61;
pub const RM_BOSS: ::libc::c_uint = 62;
pub const RM_DBM: ::libc::c_uint = 63;
pub const RM_CONFIG: ::libc::c_uint = 64;
pub const RM_PS: ::libc::c_uint = 65;
pub const RM_CEC: ::libc::c_uint = 66;
pub const RM_IR: ::libc::c_uint = 67;
pub const RM_UDS: ::libc::c_uint = 68;
pub const RM_PL: ::libc::c_uint = 69;
pub const RM_CUP: ::libc::c_uint = 70;
pub const RM_GYROSCOPE: ::libc::c_uint = 71;
pub const RM_MCU: ::libc::c_uint = 72;
pub const RM_NS: ::libc::c_uint = 73;
pub const RM_NEWS: ::libc::c_uint = 74;
pub const RM_RO: ::libc::c_uint = 75;
pub const RM_GD: ::libc::c_uint = 76;
pub const RM_CARD_SPI: ::libc::c_uint = 77;
pub const RM_EC: ::libc::c_uint = 78;
pub const RM_WEB_BROWSER: ::libc::c_uint = 79;
pub const RM_TEST: ::libc::c_uint = 80;
pub const RM_ENC: ::libc::c_uint = 81;
pub const RM_PIA: ::libc::c_uint = 82;
pub const RM_ACT: ::libc::c_uint = 83;
pub const RM_VCTL: ::libc::c_uint = 84;
pub const RM_OLV: ::libc::c_uint = 85;
pub const RM_NEIA: ::libc::c_uint = 86;
pub const RM_NPNS: ::libc::c_uint = 87;
pub const RM_AVD: ::libc::c_uint = 90;
pub const RM_L2B: ::libc::c_uint = 91;
pub const RM_MVD: ::libc::c_uint = 92;
pub const RM_NFC: ::libc::c_uint = 93;
pub const RM_UART: ::libc::c_uint = 94;
pub const RM_SPM: ::libc::c_uint = 95;
pub const RM_QTM: ::libc::c_uint = 96;
pub const RM_NFP: ::libc::c_uint = 97;
pub const RM_APPLICATION: ::libc::c_uint = 254;
pub const RM_INVALIDRESVAL: ::libc::c_uint = 255;
pub type _bindgen_ty_3 = ::libc::c_uint;
pub const RD_SUCCESS: ::libc::c_uint = 0;
pub const RD_INVALID_RESULT_VALUE: ::libc::c_uint = 1023;
pub const RD_TIMEOUT: ::libc::c_uint = 1022;
pub const RD_OUT_OF_RANGE: ::libc::c_uint = 1021;
pub const RD_ALREADY_EXISTS: ::libc::c_uint = 1020;
pub const RD_CANCEL_REQUESTED: ::libc::c_uint = 1019;
pub const RD_NOT_FOUND: ::libc::c_uint = 1018;
pub const RD_ALREADY_INITIALIZED: ::libc::c_uint = 1017;
pub const RD_NOT_INITIALIZED: ::libc::c_uint = 1016;
pub const RD_INVALID_HANDLE: ::libc::c_uint = 1015;
pub const RD_INVALID_POINTER: ::libc::c_uint = 1014;
pub const RD_INVALID_ADDRESS: ::libc::c_uint = 1013;
pub const RD_NOT_IMPLEMENTED: ::libc::c_uint = 1012;
pub const RD_OUT_OF_MEMORY: ::libc::c_uint = 1011;
pub const RD_MISALIGNED_SIZE: ::libc::c_uint = 1010;
pub const RD_MISALIGNED_ADDRESS: ::libc::c_uint = 1009;
pub const RD_BUSY: ::libc::c_uint = 1008;
pub const RD_NO_DATA: ::libc::c_uint = 1007;
pub const RD_INVALID_COMBINATION: ::libc::c_uint = 1006;
pub const RD_INVALID_ENUM_VALUE: ::libc::c_uint = 1005;
pub const RD_INVALID_SIZE: ::libc::c_uint = 1004;
pub const RD_ALREADY_DONE: ::libc::c_uint = 1003;
pub const RD_NOT_AUTHORIZED: ::libc::c_uint = 1002;
pub const RD_TOO_LARGE: ::libc::c_uint = 1001;
pub const RD_INVALID_SELECTION: ::libc::c_uint = 1000;
pub type _bindgen_ty_4 = ::libc::c_uint;
pub const IPC_BUFFER_R: IPC_BufferRights = 2;
pub const IPC_BUFFER_W: IPC_BufferRights = 4;
pub const IPC_BUFFER_RW: IPC_BufferRights = 6;
pub type IPC_BufferRights = ::libc::c_uint;
pub const MEMOP_FREE: MemOp = 1;
pub const MEMOP_RESERVE: MemOp = 2;
pub const MEMOP_ALLOC: MemOp = 3;
pub const MEMOP_MAP: MemOp = 4;
pub const MEMOP_UNMAP: MemOp = 5;
pub const MEMOP_PROT: MemOp = 6;
pub const MEMOP_REGION_APP: MemOp = 256;
pub const MEMOP_REGION_SYSTEM: MemOp = 512;
pub const MEMOP_REGION_BASE: MemOp = 768;
pub const MEMOP_OP_MASK: MemOp = 255;
pub const MEMOP_REGION_MASK: MemOp = 3840;
pub const MEMOP_LINEAR_FLAG: MemOp = 65536;
pub const MEMOP_ALLOC_LINEAR: MemOp = 65539;
pub type MemOp = ::libc::c_uint;
pub const MEMSTATE_FREE: MemState = 0;
pub const MEMSTATE_RESERVED: MemState = 1;
pub const MEMSTATE_IO: MemState = 2;
pub const MEMSTATE_STATIC: MemState = 3;
pub const MEMSTATE_CODE: MemState = 4;
pub const MEMSTATE_PRIVATE: MemState = 5;
pub const MEMSTATE_SHARED: MemState = 6;
pub const MEMSTATE_CONTINUOUS: MemState = 7;
pub const MEMSTATE_ALIASED: MemState = 8;
pub const MEMSTATE_ALIAS: MemState = 9;
pub const MEMSTATE_ALIASCODE: MemState = 10;
pub const MEMSTATE_LOCKED: MemState = 11;
pub type MemState = ::libc::c_uint;
pub const MEMPERM_READ: MemPerm = 1;
pub const MEMPERM_WRITE: MemPerm = 2;
pub const MEMPERM_EXECUTE: MemPerm = 4;
pub const MEMPERM_READWRITE: MemPerm = 3;
pub const MEMPERM_READEXECUTE: MemPerm = 5;
pub const MEMPERM_DONTCARE: MemPerm = 268435456;
pub type MemPerm = ::libc::c_uint;
pub const MEMREGION_ALL: MemRegion = 0;
pub const MEMREGION_APPLICATION: MemRegion = 1;
pub const MEMREGION_SYSTEM: MemRegion = 2;
pub const MEMREGION_BASE: MemRegion = 3;
pub type MemRegion = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemInfo {
    pub base_addr: u32_,
    pub size: u32_,
    pub perm: u32_,
    pub state: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PageInfo {
    pub flags: u32_,
}
pub const ARBITRATION_SIGNAL: ArbitrationType = 0;
pub const ARBITRATION_WAIT_IF_LESS_THAN: ArbitrationType = 1;
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN: ArbitrationType = 2;
pub const ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 3;
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 4;
pub type ArbitrationType = ::libc::c_uint;
pub const RESET_ONESHOT: ResetType = 0;
pub const RESET_STICKY: ResetType = 1;
pub const RESET_PULSE: ResetType = 2;
pub type ResetType = ::libc::c_uint;
pub const THREADINFO_TYPE_UNKNOWN: ThreadInfoType = 0;
pub type ThreadInfoType = ::libc::c_uint;
pub const RESLIMIT_PRIORITY: ResourceLimitType = 0;
pub const RESLIMIT_COMMIT: ResourceLimitType = 1;
pub const RESLIMIT_THREAD: ResourceLimitType = 2;
pub const RESLIMIT_EVENT: ResourceLimitType = 3;
pub const RESLIMIT_MUTEX: ResourceLimitType = 4;
pub const RESLIMIT_SEMAPHORE: ResourceLimitType = 5;
pub const RESLIMIT_TIMER: ResourceLimitType = 6;
pub const RESLIMIT_SHAREDMEMORY: ResourceLimitType = 7;
pub const RESLIMIT_ADDRESSARBITER: ResourceLimitType = 8;
pub const RESLIMIT_CPUTIME: ResourceLimitType = 9;
pub const RESLIMIT_BIT: ResourceLimitType = 2147483648;
pub type ResourceLimitType = ::libc::c_uint;
pub const DMASTATE_STARTING: DmaState = 0;
pub const DMASTATE_WFP_DST: DmaState = 1;
pub const DMASTATE_WFP_SRC: DmaState = 2;
pub const DMASTATE_RUNNING: DmaState = 3;
pub const DMASTATE_DONE: DmaState = 4;
pub type DmaState = ::libc::c_uint;
pub const DMACFG_SRC_IS_DEVICE: ::libc::c_uint = 1;
pub const DMACFG_DST_IS_DEVICE: ::libc::c_uint = 2;
pub const DMACFG_WAIT_AVAILABLE: ::libc::c_uint = 4;
pub const DMACFG_KEEP_LOCKED: ::libc::c_uint = 8;
pub const DMACFG_USE_SRC_CONFIG: ::libc::c_uint = 64;
pub const DMACFG_USE_DST_CONFIG: ::libc::c_uint = 128;
pub type _bindgen_ty_5 = ::libc::c_uint;
pub const DMARST_UNLOCK: ::libc::c_uint = 1;
pub const DMARST_RESUME_DEVICE: ::libc::c_uint = 2;
pub type _bindgen_ty_6 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DmaDeviceConfig {
    pub deviceId: s8,
    pub allowedAlignments: s8,
    pub burstSize: s16,
    pub transferSize: s16,
    pub burstStride: s16,
    pub transferStride: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DmaConfig {
    pub channelId: s8,
    pub endianSwapSize: s8,
    pub flags: u8_,
    pub _padding: u8_,
    pub srcCfg: DmaDeviceConfig,
    pub dstCfg: DmaDeviceConfig,
}
pub const PERFCOUNTEROP_ENABLE: PerfCounterOperation = 0;
pub const PERFCOUNTEROP_DISABLE: PerfCounterOperation = 1;
pub const PERFCOUNTEROP_GET_VALUE: PerfCounterOperation = 2;
pub const PERFCOUNTEROP_SET_VALUE: PerfCounterOperation = 3;
pub const PERFCOUNTEROP_GET_OVERFLOW_FLAGS: PerfCounterOperation = 4;
pub const PERFCOUNTEROP_RESET: PerfCounterOperation = 5;
pub const PERFCOUNTEROP_GET_EVENT: PerfCounterOperation = 6;
pub const PERFCOUNTEROP_SET_EVENT: PerfCounterOperation = 7;
pub const PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED: PerfCounterOperation = 8;
pub type PerfCounterOperation = ::libc::c_uint;
pub const PERFCOUNTERREG_CORE_BASE: PerfCounterRegister = 0;
pub const PERFCOUNTERREG_CORE_COUNT_REG_0: PerfCounterRegister = 0;
pub const PERFCOUNTERREG_CORE_COUNT_REG_1: PerfCounterRegister = 1;
pub const PERFCOUNTERREG_CORE_CYCLE_COUNTER: PerfCounterRegister = 2;
pub const PERFCOUNTERREG_SCU_BASE: PerfCounterRegister = 16;
pub const PERFCOUNTERREG_SCU_0: PerfCounterRegister = 16;
pub const PERFCOUNTERREG_SCU_1: PerfCounterRegister = 17;
pub const PERFCOUNTERREG_SCU_2: PerfCounterRegister = 18;
pub const PERFCOUNTERREG_SCU_3: PerfCounterRegister = 19;
pub const PERFCOUNTERREG_SCU_4: PerfCounterRegister = 20;
pub const PERFCOUNTERREG_SCU_5: PerfCounterRegister = 21;
pub const PERFCOUNTERREG_SCU_6: PerfCounterRegister = 22;
pub const PERFCOUNTERREG_SCU_7: PerfCounterRegister = 23;
pub type PerfCounterRegister = ::libc::c_uint;
pub const PERFCOUNTEREVT_CORE_BASE: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_INST_CACHE_MISS: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LACK_OF_INST: PerfCounterEvent = 1;
pub const PERFCOUNTEREVT_CORE_STALL_BY_DATA_HAZARD: PerfCounterEvent = 2;
pub const PERFCOUNTEREVT_CORE_INST_MICRO_TLB_MISS: PerfCounterEvent = 3;
pub const PERFCOUNTEREVT_CORE_DATA_MICRO_TLB_MISS: PerfCounterEvent = 4;
pub const PERFCOUNTEREVT_CORE_BRANCH_INST: PerfCounterEvent = 5;
pub const PERFCOUNTEREVT_CORE_BRANCH_NOT_PREDICTED: PerfCounterEvent = 6;
pub const PERFCOUNTEREVT_CORE_BRANCH_MISS_PREDICTED: PerfCounterEvent = 7;
pub const PERFCOUNTEREVT_CORE_INST_EXECUTED: PerfCounterEvent = 8;
pub const PERFCOUNTEREVT_CORE_FOLDED_INST_EXECUTED: PerfCounterEvent = 9;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ: PerfCounterEvent = 10;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ_MISS: PerfCounterEvent = 11;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE: PerfCounterEvent = 12;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE_MISS: PerfCounterEvent = 13;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_LINE_EVICTION: PerfCounterEvent = 14;
pub const PERFCOUNTEREVT_CORE_PC_CHANGED: PerfCounterEvent = 15;
pub const PERFCOUNTEREVT_CORE_MAIN_TLB_MISS: PerfCounterEvent = 16;
pub const PERFCOUNTEREVT_CORE_EXTERNAL_REQUEST: PerfCounterEvent = 17;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LSU_FULL: PerfCounterEvent = 18;
pub const PERFCOUNTEREVT_CORE_STORE_BUFFER_DRAIN: PerfCounterEvent = 19;
pub const PERFCOUNTEREVT_CORE_MERGE_IN_STORE_BUFFER: PerfCounterEvent = 20;
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT: PerfCounterEvent = 255;
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT_64: PerfCounterEvent = 4095;
pub const PERFCOUNTEREVT_SCU_BASE: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_DISABLED: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE0: PerfCounterEvent = 4097;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE1: PerfCounterEvent = 4098;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE2: PerfCounterEvent = 4099;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE3: PerfCounterEvent = 4100;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE0: PerfCounterEvent = 4101;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE1: PerfCounterEvent = 4102;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE2: PerfCounterEvent = 4103;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE3: PerfCounterEvent = 4104;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE0: PerfCounterEvent = 4105;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE1: PerfCounterEvent = 4106;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE2: PerfCounterEvent = 4107;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE3: PerfCounterEvent = 4108;
pub const PERFCOUNTEREVT_SCU_LINE_MIGRATION: PerfCounterEvent = 4109;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT0: PerfCounterEvent = 4110;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT1: PerfCounterEvent = 4111;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT0: PerfCounterEvent = 4112;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT1: PerfCounterEvent = 4113;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_READ: PerfCounterEvent = 4114;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_WRITE: PerfCounterEvent = 4115;
pub const PERFCOUNTEREVT_SCU_CYCLE_COUNT: PerfCounterEvent = 4127;
pub type PerfCounterEvent = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachProcessEvent {
    pub program_id: u64_,
    pub process_name: [::libc::c_char; 8usize],
    pub process_id: u32_,
    pub other_flags: u32_,
}
pub const EXITPROCESS_EVENT_EXIT: ExitProcessEventReason = 0;
pub const EXITPROCESS_EVENT_TERMINATE: ExitProcessEventReason = 1;
pub const EXITPROCESS_EVENT_DEBUG_TERMINATE: ExitProcessEventReason = 2;
pub type ExitProcessEventReason = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitProcessEvent {
    pub reason: ExitProcessEventReason,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttachThreadEvent {
    pub creator_thread_id: u32_,
    pub thread_local_storage: u32_,
    pub entry_point: u32_,
}
pub const EXITTHREAD_EVENT_EXIT: ExitThreadEventReason = 0;
pub const EXITTHREAD_EVENT_TERMINATE: ExitThreadEventReason = 1;
pub const EXITTHREAD_EVENT_EXIT_PROCESS: ExitThreadEventReason = 2;
pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ExitThreadEventReason = 3;
pub type ExitThreadEventReason = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitThreadEvent {
    pub reason: ExitThreadEventReason,
}
pub const USERBREAK_PANIC: UserBreakType = 0;
pub const USERBREAK_ASSERT: UserBreakType = 1;
pub const USERBREAK_USER: UserBreakType = 2;
pub const USERBREAK_LOAD_RO: UserBreakType = 3;
pub const USERBREAK_UNLOAD_RO: UserBreakType = 4;
pub type UserBreakType = ::libc::c_uint;
pub const EXCEVENT_UNDEFINED_INSTRUCTION: ExceptionEventType = 0;
pub const EXCEVENT_PREFETCH_ABORT: ExceptionEventType = 1;
pub const EXCEVENT_DATA_ABORT: ExceptionEventType = 2;
pub const EXCEVENT_UNALIGNED_DATA_ACCESS: ExceptionEventType = 3;
pub const EXCEVENT_ATTACH_BREAK: ExceptionEventType = 4;
pub const EXCEVENT_STOP_POINT: ExceptionEventType = 5;
pub const EXCEVENT_USER_BREAK: ExceptionEventType = 6;
pub const EXCEVENT_DEBUGGER_BREAK: ExceptionEventType = 7;
pub const EXCEVENT_UNDEFINED_SYSCALL: ExceptionEventType = 8;
pub type ExceptionEventType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FaultExceptionEvent {
    pub fault_information: u32_,
}
pub const STOPPOINT_SVC_FF: StopPointType = 0;
pub const STOPPOINT_BREAKPOINT: StopPointType = 1;
pub const STOPPOINT_WATCHPOINT: StopPointType = 2;
pub type StopPointType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPointExceptionEvent {
    pub type_: StopPointType,
    pub fault_information: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserBreakExceptionEvent {
    pub type_: UserBreakType,
    pub croInfo: u32_,
    pub croInfoSize: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DebuggerBreakExceptionEvent {
    pub thread_ids: [s32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExceptionEvent {
    pub type_: ExceptionEventType,
    pub address: u32_,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExceptionEvent__bindgen_ty_1 {
    pub fault: FaultExceptionEvent,
    pub stop_point: StopPointExceptionEvent,
    pub user_break: UserBreakExceptionEvent,
    pub debugger_break: DebuggerBreakExceptionEvent,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScheduleInOutEvent {
    pub clock_tick: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SyscallInOutEvent {
    pub clock_tick: u64_,
    pub syscall: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OutputStringEvent {
    pub string_addr: u32_,
    pub string_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapEvent {
    pub mapped_addr: u32_,
    pub mapped_size: u32_,
    pub memperm: MemPerm,
    pub memstate: MemState,
}
pub const DBGEVENT_ATTACH_PROCESS: DebugEventType = 0;
pub const DBGEVENT_ATTACH_THREAD: DebugEventType = 1;
pub const DBGEVENT_EXIT_THREAD: DebugEventType = 2;
pub const DBGEVENT_EXIT_PROCESS: DebugEventType = 3;
pub const DBGEVENT_EXCEPTION: DebugEventType = 4;
pub const DBGEVENT_DLL_LOAD: DebugEventType = 5;
pub const DBGEVENT_DLL_UNLOAD: DebugEventType = 6;
pub const DBGEVENT_SCHEDULE_IN: DebugEventType = 7;
pub const DBGEVENT_SCHEDULE_OUT: DebugEventType = 8;
pub const DBGEVENT_SYSCALL_IN: DebugEventType = 9;
pub const DBGEVENT_SYSCALL_OUT: DebugEventType = 10;
pub const DBGEVENT_OUTPUT_STRING: DebugEventType = 11;
pub const DBGEVENT_MAP: DebugEventType = 12;
pub type DebugEventType = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugEventInfo {
    pub type_: DebugEventType,
    pub thread_id: u32_,
    pub flags: u32_,
    pub remnants: [u8_; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DebugEventInfo__bindgen_ty_1 {
    pub attach_process: AttachProcessEvent,
    pub attach_thread: AttachThreadEvent,
    pub exit_thread: ExitThreadEvent,
    pub exit_process: ExitProcessEvent,
    pub exception: ExceptionEvent,
    pub scheduler: ScheduleInOutEvent,
    pub syscall: SyscallInOutEvent,
    pub output_string: OutputStringEvent,
    pub map: MapEvent,
}
pub const DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS: DebugFlags = 1;
pub const DBG_SIGNAL_FAULT_EXCEPTION_EVENTS: DebugFlags = 2;
pub const DBG_SIGNAL_SCHEDULE_EVENTS: DebugFlags = 4;
pub const DBG_SIGNAL_SYSCALL_EVENTS: DebugFlags = 8;
pub const DBG_SIGNAL_MAP_EVENTS: DebugFlags = 16;
pub type DebugFlags = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ThreadContext {
    pub cpu_registers: CpuRegisters,
    pub fpu_registers: FpuRegisters,
}
pub const THREADCONTEXT_CONTROL_CPU_GPRS: ThreadContextControlFlags = 1;
pub const THREADCONTEXT_CONTROL_CPU_SPRS: ThreadContextControlFlags = 2;
pub const THREADCONTEXT_CONTROL_FPU_GPRS: ThreadContextControlFlags = 4;
pub const THREADCONTEXT_CONTROL_FPU_SPRS: ThreadContextControlFlags = 8;
pub const THREADCONTEXT_CONTROL_CPU_REGS: ThreadContextControlFlags = 3;
pub const THREADCONTEXT_CONTROL_FPU_REGS: ThreadContextControlFlags = 12;
pub const THREADCONTEXT_CONTROL_ALL: ThreadContextControlFlags = 15;
pub type ThreadContextControlFlags = ::libc::c_uint;
pub const DBGTHREAD_PARAMETER_PRIORITY: DebugThreadParameter = 0;
pub const DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW: DebugThreadParameter = 1;
pub const DBGTHREAD_PARAMETER_CPU_IDEAL: DebugThreadParameter = 2;
pub const DBGTHREAD_PARAMETER_CPU_CREATOR: DebugThreadParameter = 3;
pub type DebugThreadParameter = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CodeSetHeader {
    pub name: [u8_; 8usize],
    pub version: u16_,
    pub padding: [u16_; 3usize],
    pub text_addr: u32_,
    pub text_size: u32_,
    pub ro_addr: u32_,
    pub ro_size: u32_,
    pub rw_addr: u32_,
    pub rw_size: u32_,
    pub text_size_total: u32_,
    pub ro_size_total: u32_,
    pub rw_size_total: u32_,
    pub padding2: u32_,
    pub program_id: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartupInfo {
    pub priority: ::libc::c_int,
    pub stack_size: u32_,
    pub argc: ::libc::c_int,
    pub argv: *mut u16_,
    pub envp: *mut u16_,
}
extern "C" {
    pub fn svcControlMemory(
        addr_out: *mut u32_,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        op: MemOp,
        perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcControlProcessMemory(
        process: Handle,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        type_: u32_,
        perm: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateMemoryBlock(
        memblock: *mut Handle,
        addr: u32_,
        size: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcMapMemoryBlock(
        memblock: Handle,
        addr: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32_) -> Result;
}
extern "C" {
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32_) -> Result;
}
extern "C" {
    pub fn svcQueryProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        process: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcOpenProcess(process: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    pub fn svcExitProcess();
}
extern "C" {
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32_) -> Result;
}
extern "C" {
    pub fn svcGetProcessId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessList(
        processCount: *mut s32,
        processIds: *mut u32_,
        processIdMaxCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetThreadList(
        threadCount: *mut s32,
        threadIds: *mut u32_,
        threadIdMaxCount: s32,
        process: Handle,
    ) -> Result;
}
extern "C" {
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn svcCreateCodeSet(
        out: *mut Handle,
        info: *const CodeSetHeader,
        textSegmentLma: u32_,
        roSegmentLma: u32_,
        dataSegmentLma: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateProcess(
        out: *mut Handle,
        codeset: Handle,
        arm11KernelCaps: *const u32_,
        numArm11KernelCaps: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessAffinityMask(
        affinitymask: *mut u8_,
        process: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetProcessAffinityMask(
        process: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle) -> Result;
}
extern "C" {
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32) -> Result;
}
extern "C" {
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
extern "C" {
    pub fn svcCreateThread(
        thread: *mut Handle,
        entrypoint: ThreadFunc,
        arg: u32_,
        stack_top: *mut u32_,
        thread_priority: s32,
        processor_id: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32_) -> Result;
}
extern "C" {
    pub fn svcExitThread();
}
extern "C" {
    pub fn svcSleepThread(ns: s64);
}
extern "C" {
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
extern "C" {
    pub fn svcGetThreadAffinityMask(
        affinitymask: *mut u8_,
        thread: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetThreadAffinityMask(
        thread: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle) -> Result;
}
extern "C" {
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32) -> Result;
}
extern "C" {
    pub fn svcGetProcessorID() -> s32;
}
extern "C" {
    pub fn svcGetThreadId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitLimitValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitCurrentValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcSetResourceLimitValues(
        resourceLimit: Handle,
        names: *const ResourceLimitType,
        values: *const s64,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcGetProcessIdOfThread(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle, type_: ThreadInfoType) -> Result;
}
extern "C" {
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool) -> Result;
}
extern "C" {
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32, max_count: s32)
        -> Result;
}
extern "C" {
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle, release_count: s32) -> Result;
}
extern "C" {
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronizationN(
        out: *mut s32,
        handles: *const Handle,
        handles_num: s32,
        wait_all: bool,
        nanoseconds: s64,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcArbitrateAddress(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    pub fn svcArbitrateAddressNoTimeout(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
    ) -> Result;
}
extern "C" {
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSessionToPort(clientSession: *mut Handle, clientPort: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSession(serverSession: *mut Handle, clientSession: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
    ) -> Result;
}
extern "C" {
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
extern "C" {
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcClearTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcGetSystemTick() -> u64_;
}
extern "C" {
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
extern "C" {
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32_) -> Result;
}
extern "C" {
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32_, param: s32) -> Result;
}
extern "C" {
    pub fn svcKernelSetState(type_: u32_, ...) -> Result;
}
extern "C" {
    pub fn svcBindInterrupt(
        interruptId: u32_,
        eventOrSemaphore: Handle,
        priority: s32,
        isManualClear: bool,
    ) -> Result;
}
extern "C" {
    pub fn svcUnbindInterrupt(interruptId: u32_, eventOrSemaphore: Handle) -> Result;
}
extern "C" {
    pub fn svcInvalidateProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn svcStoreProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn svcFlushProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn svcStartInterProcessDma(
        dma: *mut Handle,
        dstProcess: Handle,
        dstAddr: u32_,
        srcProcess: Handle,
        srcAddr: u32_,
        size: u32_,
        cfg: *const DmaConfig,
    ) -> Result;
}
extern "C" {
    pub fn svcStopDma(dma: Handle) -> Result;
}
extern "C" {
    pub fn svcGetDmaState(state: *mut DmaState, dma: Handle) -> Result;
}
extern "C" {
    pub fn svcRestartDma(
        dma: Handle,
        dstAddr: u32_,
        srcAddr: u32_,
        size: u32_,
        flags: s8,
    ) -> Result;
}
extern "C" {
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
extern "C" {
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
extern "C" {
    pub fn svcBreak(breakReason: UserBreakType);
}
extern "C" {
    pub fn svcBreakRO(
        breakReason: UserBreakType,
        croInfo: *const ::libc::c_void,
        croInfoSize: u32_,
    );
}
extern "C" {
    pub fn svcOutputDebugString(str_: *const ::libc::c_char, length: s32) -> Result;
}
extern "C" {
    pub fn svcControlPerformanceCounter(
        out: *mut u64_,
        op: PerfCounterOperation,
        param1: u32_,
        param2: u64_,
    ) -> Result;
}
extern "C" {
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle) -> Result;
}
extern "C" {
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadContext(
        context: *mut ThreadContext,
        debug: Handle,
        threadId: u32_,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadId: u32_,
        context: *mut ThreadContext,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    pub fn svcQueryDebugProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        debug: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcReadProcessMemory(
        buffer: *mut ::libc::c_void,
        debug: Handle,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcWriteProcessMemory(
        debug: Handle,
        buffer: *const ::libc::c_void,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32_, value: u32_) -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadParam(
        unused: *mut s64,
        out: *mut u32_,
        debug: Handle,
        threadId: u32_,
        parameter: DebugThreadParameter,
    ) -> Result;
}
extern "C" {
    pub fn svcBackdoor(callback: ::core::option::Option<unsafe extern "C" fn() -> s32>) -> Result;
}
pub const ARM9DESC_MOUNT_NAND: ::libc::c_uint = 1;
pub const ARM9DESC_MOUNT_NANDRO_RW: ::libc::c_uint = 2;
pub const ARM9DESC_MOUNT_TWLN: ::libc::c_uint = 4;
pub const ARM9DESC_MOUNT_WNAND: ::libc::c_uint = 8;
pub const ARM9DESC_MOUNT_CARDSPI: ::libc::c_uint = 16;
pub const ARM9DESC_USE_SDIF3: ::libc::c_uint = 32;
pub const ARM9DESC_CREATE_SEED: ::libc::c_uint = 64;
pub const ARM9DESC_USE_CARD_SPI: ::libc::c_uint = 128;
pub const ARM9DESC_SD_APPLICATION: ::libc::c_uint = 256;
pub const ARM9DESC_MOUNT_SDMC_RW: ::libc::c_uint = 512;
pub type _bindgen_ty_7 = ::libc::c_uint;
pub const FSACCESS_CATEGORY_SYSTEM_APPLICATION: ::libc::c_uint = 1;
pub const FSACCESS_CATEGORY_HARDWARE_CHECK: ::libc::c_uint = 2;
pub const FSACCESS_CATEGORY_FILESYSTEM_TOOL: ::libc::c_uint = 4;
pub const FSACCESS_DEBUG: ::libc::c_uint = 8;
pub const FSACCESS_TWLCARD_BACKUP: ::libc::c_uint = 16;
pub const FSACCESS_TWLNAND_DATA: ::libc::c_uint = 32;
pub const FSACCESS_BOSS: ::libc::c_uint = 64;
pub const FSACCESS_SDMC_RW: ::libc::c_uint = 128;
pub const FSACCESS_CORE: ::libc::c_uint = 256;
pub const FSACCESS_NANDRO_RO: ::libc::c_uint = 512;
pub const FSACCESS_NANDRW: ::libc::c_uint = 1024;
pub const FSACCESS_NANDRO_RW: ::libc::c_uint = 2048;
pub const FSACCESS_CATEGORY_SYSTEM_SETTINGS: ::libc::c_uint = 4096;
pub const FSACCESS_CARDBOARD: ::libc::c_uint = 8192;
pub const FSACCESS_EXPORT_IMPORT_IVS: ::libc::c_uint = 16384;
pub const FSACCESS_SDMC_WO: ::libc::c_uint = 32768;
pub const FSACCESS_SWITCH_CLEANUP: ::libc::c_uint = 65536;
pub const FSACCESS_SAVEDATA_MOVE: ::libc::c_uint = 131072;
pub const FSACCESS_SHOP: ::libc::c_uint = 262144;
pub const FSACCESS_SHELL: ::libc::c_uint = 524288;
pub const FSACCESS_CATEGORY_HOME_MENU: ::libc::c_uint = 1048576;
pub const FSACCESS_SEEDDB: ::libc::c_uint = 2097152;
pub type _bindgen_ty_8 = ::libc::c_uint;
pub const RESLIMIT_CATEGORY_APPLICATION: ResourceLimitCategory = 0;
pub const RESLIMIT_CATEGORY_SYS_APPLET: ResourceLimitCategory = 1;
pub const RESLIMIT_CATEGORY_LIB_APPLET: ResourceLimitCategory = 2;
pub const RESLIMIT_CATEGORY_OTHER: ResourceLimitCategory = 3;
pub type ResourceLimitCategory = ::libc::c_uint;
pub const SYSMODE_O3DS_PROD: SystemMode = 0;
pub const SYSMODE_N3DS_PROD: SystemMode = 1;
pub const SYSMODE_DEV1: SystemMode = 2;
pub const SYSMODE_DEV2: SystemMode = 3;
pub const SYSMODE_DEV3: SystemMode = 4;
pub const SYSMODE_DEV4: SystemMode = 5;
pub type SystemMode = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemInfoFlags {
    pub reserved: [u8_; 5usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub remaster_version: u16_,
}
impl ExHeader_SystemInfoFlags {
    #[inline]
    pub fn compress_exefs_code(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compress_exefs_code(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sd_application(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sd_application(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compress_exefs_code: bool,
        is_sd_application: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compress_exefs_code: u8 = unsafe { ::core::mem::transmute(compress_exefs_code) };
            compress_exefs_code as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sd_application: u8 = unsafe { ::core::mem::transmute(is_sd_application) };
            is_sd_application as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_CodeSectionInfo {
    pub address: u32_,
    pub num_pages: u32_,
    pub size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_CodeSetInfo {
    pub name: [::libc::c_char; 8usize],
    pub flags: ExHeader_SystemInfoFlags,
    pub text: ExHeader_CodeSectionInfo,
    pub stack_size: u32_,
    pub rodata: ExHeader_CodeSectionInfo,
    pub reserved: u32_,
    pub data: ExHeader_CodeSectionInfo,
    pub bss_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemInfo {
    pub savedata_size: u64_,
    pub jump_id: u64_,
    pub reserved: [u8_; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemControlInfo {
    pub codeset_info: ExHeader_CodeSetInfo,
    pub dependencies: [u64_; 48usize],
    pub system_info: ExHeader_SystemInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11StorageInfo {
    pub extdata_id: u64_,
    pub system_savedata_ids: [u32_; 2usize],
    pub accessible_savedata_ids: u64_,
    pub fs_access_info: u32_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ExHeader_Arm11StorageInfo {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn no_romfs(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_romfs(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_extended_savedata_access(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_extended_savedata_access(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        no_romfs: bool,
        use_extended_savedata_access: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let no_romfs: u8 = unsafe { ::core::mem::transmute(no_romfs) };
            no_romfs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_extended_savedata_access: u8 =
                unsafe { ::core::mem::transmute(use_extended_savedata_access) };
            use_extended_savedata_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11CoreInfo {
    pub core_version: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub priority: u8_,
}
impl ExHeader_Arm11CoreInfo {
    #[inline]
    pub fn use_cpu_clockrate_804MHz(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_cpu_clockrate_804MHz(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_l2c(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_l2c(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag1_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag1_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_n3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flag2_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_flag2_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ideal_processor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ideal_processor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn affinity_mask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_affinity_mask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn o3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_o3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_cpu_clockrate_804MHz: bool,
        enable_l2c: bool,
        flag1_unused: u8_,
        n3ds_system_mode: SystemMode,
        flag2_unused: u8_,
        ideal_processor: u8_,
        affinity_mask: u8_,
        o3ds_system_mode: SystemMode,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_cpu_clockrate_804MHz: u8 =
                unsafe { ::core::mem::transmute(use_cpu_clockrate_804MHz) };
            use_cpu_clockrate_804MHz as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_l2c: u8 = unsafe { ::core::mem::transmute(enable_l2c) };
            enable_l2c as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag1_unused: u8 = unsafe { ::core::mem::transmute(flag1_unused) };
            flag1_unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let n3ds_system_mode: u32 = unsafe { ::core::mem::transmute(n3ds_system_mode) };
            n3ds_system_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flag2_unused: u8 = unsafe { ::core::mem::transmute(flag2_unused) };
            flag2_unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ideal_processor: u8 = unsafe { ::core::mem::transmute(ideal_processor) };
            ideal_processor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let affinity_mask: u8 = unsafe { ::core::mem::transmute(affinity_mask) };
            affinity_mask as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let o3ds_system_mode: u32 = unsafe { ::core::mem::transmute(o3ds_system_mode) };
            o3ds_system_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11SystemLocalCapabilities {
    pub title_id: u64_,
    pub core_info: ExHeader_Arm11CoreInfo,
    pub reslimits: [u16_; 16usize],
    pub storage_info: ExHeader_Arm11StorageInfo,
    pub service_access: [[::libc::c_char; 8usize]; 34usize],
    pub reserved: [u8_; 15usize],
    pub reslimit_category: ResourceLimitCategory,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11KernelCapabilities {
    pub descriptors: [u32_; 28usize],
    pub reserved: [u8_; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm9AccessControl {
    pub descriptors: [u8_; 15usize],
    pub descriptor_version: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessControlInfo {
    pub local_caps: ExHeader_Arm11SystemLocalCapabilities,
    pub kernel_caps: ExHeader_Arm11KernelCapabilities,
    pub access_control: ExHeader_Arm9AccessControl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Info {
    pub sci: ExHeader_SystemControlInfo,
    pub aci: ExHeader_AccessControlInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessDescriptor {
    pub signature: [u8_; 256usize],
    pub ncchModulus: [u8_; 256usize],
    pub acli: ExHeader_AccessControlInfo,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader {
    pub info: ExHeader_Info,
    pub access_descriptor: ExHeader_AccessDescriptor,
}
extern "C" {
    pub fn srvInit() -> Result;
}
extern "C" {
    pub fn srvExit();
}
extern "C" {
    pub fn srvSetBlockingPolicy(nonBlocking: bool);
}
extern "C" {
    pub fn srvGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvRegisterClient() -> Result;
}
extern "C" {
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
extern "C" {
    pub fn srvRegisterService(
        out: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: ::libc::c_int,
    ) -> Result;
}
extern "C" {
    pub fn srvUnregisterService(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetServiceHandleDirect(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvRegisterPort(name: *const ::libc::c_char, clientHandle: Handle) -> Result;
}
extern "C" {
    pub fn srvUnregisterPort(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetPort(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvWaitForPortRegistered(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvSubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    pub fn srvUnsubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    pub fn srvReceiveNotification(notificationIdOut: *mut u32_) -> Result;
}
extern "C" {
    pub fn srvPublishToSubscriber(notificationId: u32_, flags: u32_) -> Result;
}
extern "C" {
    pub fn srvPublishAndGetSubscriber(
        processIdCountOut: *mut u32_,
        processIdsOut: *mut u32_,
        notificationId: u32_,
    ) -> Result;
}
extern "C" {
    pub fn srvIsServiceRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn srvIsPortRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
pub const ERRF_ERRTYPE_GENERIC: ERRF_ErrType = 0;
pub const ERRF_ERRTYPE_NAND_DAMAGED: ERRF_ErrType = 1;
pub const ERRF_ERRTYPE_CARD_REMOVED: ERRF_ErrType = 2;
pub const ERRF_ERRTYPE_EXCEPTION: ERRF_ErrType = 3;
pub const ERRF_ERRTYPE_FAILURE: ERRF_ErrType = 4;
pub const ERRF_ERRTYPE_LOG_ONLY: ERRF_ErrType = 5;
pub type ERRF_ErrType = ::libc::c_uint;
pub const ERRF_EXCEPTION_PREFETCH_ABORT: ERRF_ExceptionType = 0;
pub const ERRF_EXCEPTION_DATA_ABORT: ERRF_ExceptionType = 1;
pub const ERRF_EXCEPTION_UNDEFINED: ERRF_ExceptionType = 2;
pub const ERRF_EXCEPTION_VFP: ERRF_ExceptionType = 3;
pub type ERRF_ExceptionType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionInfo {
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8_; 3usize],
    pub fsr: u32_,
    pub far: u32_,
    pub fpexc: u32_,
    pub fpinst: u32_,
    pub fpinst2: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionData {
    pub excep: ERRF_ExceptionInfo,
    pub regs: CpuRegisters,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ERRF_FatalErrInfo {
    pub type_: ERRF_ErrType,
    pub revHigh: u8_,
    pub revLow: u16_,
    pub resCode: u32_,
    pub pcAddr: u32_,
    pub procId: u32_,
    pub titleId: u64_,
    pub appTitleId: u64_,
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ERRF_FatalErrInfo__bindgen_ty_1 {
    pub exception_data: ERRF_ExceptionData,
    pub failure_mesg: [::libc::c_char; 96usize],
}
extern "C" {
    pub fn errfInit() -> Result;
}
extern "C" {
    pub fn errfExit();
}
extern "C" {
    pub fn errfGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
extern "C" {
    pub fn ERRF_LogResult(failure: Result) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResultWithMessage(failure: Result, message: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ERRF_SetUserString(user_string: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osKernelConfig_s {
    pub kernel_ver: u32_,
    pub update_flag: u32_,
    pub ns_tid: u64_,
    pub kernel_syscore_ver: u32_,
    pub env_info: u8_,
    pub unit_info: u8_,
    pub boot_env: u8_,
    pub unk_0x17: u8_,
    pub kernel_ctrsdk_ver: u32_,
    pub unk_0x1c: u32_,
    pub firmlaunch_flags: u32_,
    pub unk_0x24: [u8_; 12usize],
    pub app_memtype: u32_,
    pub unk_0x34: [u8_; 12usize],
    pub memregion_sz: [u32_; 3usize],
    pub unk_0x4c: [u8_; 20usize],
    pub firm_ver: u32_,
    pub firm_syscore_ver: u32_,
    pub firm_ctrsdk_ver: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osTimeRef_s {
    pub value_ms: u64_,
    pub value_tick: u64_,
    pub sysclock_hz: s64,
    pub drift_ms: s64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osSharedConfig_s {
    pub timeref_cnt: vu32,
    pub running_hw: u8_,
    pub mcu_hwinfo: u8_,
    pub unk_0x06: [u8_; 26usize],
    pub timeref: [osTimeRef_s; 2usize],
    pub wifi_macaddr: [u8_; 6usize],
    pub wifi_strength: vu8,
    pub network_state: vu8,
    pub unk_0x68: [u8_; 24usize],
    pub slider_3d: f32,
    pub led_3d: vu8,
    pub led_battery: vu8,
    pub unk_flag: vu8,
    pub unk_0x87: u8_,
    pub unk_0x88: [u8_; 24usize],
    pub menu_tid: vu64,
    pub cur_menu_tid: vu64,
    pub unk_0xB0: [u8_; 16usize],
    pub headset_connected: vu8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TickCounter {
    pub elapsed: u64_,
    pub reference: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OS_VersionBin {
    pub build: u8_,
    pub minor: u8_,
    pub mainver: u8_,
    pub reserved_x3: u8_,
    pub region: ::libc::c_char,
    pub reserved_x5: [u8_; 3usize],
}
extern "C" {
    pub fn osConvertVirtToPhys(vaddr: *const ::libc::c_void) -> u32_;
}
extern "C" {
    pub fn osConvertOldLINEARMemToNew(vaddr: *const ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn osStrError(error: Result) -> *const ::libc::c_char;
}
extern "C" {
    pub fn osGetTimeRef() -> osTimeRef_s;
}
extern "C" {
    pub fn osGetTime() -> u64_;
}
extern "C" {
    pub fn osTickCounterRead(cnt: *const TickCounter) -> f64;
}
extern "C" {
    pub fn osSetSpeedupEnable(enable: bool);
}
extern "C" {
    pub fn osGetSystemVersionData(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
    ) -> Result;
}
extern "C" {
    pub fn osGetSystemVersionDataString(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
        sysverstr: *mut ::libc::c_char,
        sysverstr_maxsize: u32_,
    ) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
pub type LightLock = _LOCK_T;
pub type RecursiveLock = _LOCK_RECURSIVE_T;
pub type CondVar = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LightEvent {
    pub state: s32,
    pub lock: LightLock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LightSemaphore {
    pub current_count: s32,
    pub num_threads_acq: s16,
    pub max_count: s16,
}
extern "C" {
    pub fn syncArbitrateAddress(addr: *mut s32, type_: ArbitrationType, value: s32) -> Result;
}
extern "C" {
    pub fn syncArbitrateAddressWithTimeout(
        addr: *mut s32,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    pub fn LightLock_Init(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_Lock(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_TryLock(lock: *mut LightLock) -> ::libc::c_int;
}
extern "C" {
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
extern "C" {
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> ::libc::c_int;
}
extern "C" {
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn CondVar_Init(cv: *mut CondVar);
}
extern "C" {
    pub fn CondVar_Wait(cv: *mut CondVar, lock: *mut LightLock);
}
extern "C" {
    pub fn CondVar_WaitTimeout(
        cv: *mut CondVar,
        lock: *mut LightLock,
        timeout_ns: s64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn CondVar_WakeUp(cv: *mut CondVar, num_threads: s32);
}
extern "C" {
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
extern "C" {
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
}
extern "C" {
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_WaitTimeout(event: *mut LightEvent, timeout_ns: s64) -> ::libc::c_int;
}
extern "C" {
    pub fn LightSemaphore_Init(semaphore: *mut LightSemaphore, initial_count: s16, max_count: s16);
}
extern "C" {
    pub fn LightSemaphore_Acquire(semaphore: *mut LightSemaphore, count: s32);
}
extern "C" {
    pub fn LightSemaphore_TryAcquire(semaphore: *mut LightSemaphore, count: s32) -> ::libc::c_int;
}
extern "C" {
    pub fn LightSemaphore_Release(semaphore: *mut LightSemaphore, count: s32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
pub type Thread = *mut Thread_tag;
pub type ExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters),
>;
extern "C" {
    pub fn threadCreate(
        entrypoint: ThreadFunc,
        arg: *mut ::libc::c_void,
        stack_size: size_t,
        prio: ::libc::c_int,
        core_id: ::libc::c_int,
        detached: bool,
    ) -> Thread;
}
extern "C" {
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
extern "C" {
    pub fn threadGetExitCode(thread: Thread) -> ::libc::c_int;
}
extern "C" {
    pub fn threadFree(thread: Thread);
}
extern "C" {
    pub fn threadJoin(thread: Thread, timeout_ns: u64_) -> Result;
}
extern "C" {
    pub fn threadDetach(thread: Thread);
}
extern "C" {
    pub fn threadGetCurrent() -> Thread;
}
extern "C" {
    pub fn threadExit(rc: ::libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_FramebufferInfo {
    pub active_framebuf: u32_,
    pub framebuf0_vaddr: *mut u32_,
    pub framebuf1_vaddr: *mut u32_,
    pub framebuf_widthbytesize: u32_,
    pub format: u32_,
    pub framebuf_dispselect: u32_,
    pub unk: u32_,
}
pub const GSP_RGBA8_OES: GSPGPU_FramebufferFormat = 0;
pub const GSP_BGR8_OES: GSPGPU_FramebufferFormat = 1;
pub const GSP_RGB565_OES: GSPGPU_FramebufferFormat = 2;
pub const GSP_RGB5_A1_OES: GSPGPU_FramebufferFormat = 3;
pub const GSP_RGBA4_OES: GSPGPU_FramebufferFormat = 4;
pub type GSPGPU_FramebufferFormat = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfoEntry {
    pub framebuf0_vaddr: *mut u32_,
    pub framebuf1_vaddr: *mut u32_,
    pub format: u32_,
    pub framebuf_widthbytesize: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfo {
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
pub const GSPGPU_EVENT_PSC0: GSPGPU_Event = 0;
pub const GSPGPU_EVENT_PSC1: GSPGPU_Event = 1;
pub const GSPGPU_EVENT_VBlank0: GSPGPU_Event = 2;
pub const GSPGPU_EVENT_VBlank1: GSPGPU_Event = 3;
pub const GSPGPU_EVENT_PPF: GSPGPU_Event = 4;
pub const GSPGPU_EVENT_P3D: GSPGPU_Event = 5;
pub const GSPGPU_EVENT_DMA: GSPGPU_Event = 6;
pub const GSPGPU_EVENT_MAX: GSPGPU_Event = 7;
pub type GSPGPU_Event = ::libc::c_uint;
extern "C" {
    pub fn gspInit() -> Result;
}
extern "C" {
    pub fn gspExit();
}
extern "C" {
    pub fn gspGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn gspHasGpuRight() -> bool;
}
extern "C" {
    pub fn gspPresentBuffer(
        screen: ::libc::c_uint,
        swap: ::libc::c_uint,
        fb_a: *const ::libc::c_void,
        fb_b: *const ::libc::c_void,
        stride: u32_,
        mode: u32_,
    ) -> bool;
}
extern "C" {
    pub fn gspIsPresentPending(screen: ::libc::c_uint) -> bool;
}
extern "C" {
    pub fn gspSetEventCallback(
        id: GSPGPU_Event,
        cb: ThreadFunc,
        data: *mut ::libc::c_void,
        oneShot: bool,
    );
}
extern "C" {
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
extern "C" {
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
extern "C" {
    pub fn gspSubmitGxCommand(gxCommand: *const u32_) -> Result;
}
extern "C" {
    pub fn GSPGPU_AcquireRight(flags: u8_) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReleaseRight() -> Result;
}
extern "C" {
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo: *mut GSPGPU_CaptureInfo) -> Result;
}
extern "C" {
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_ResetGpuCore() -> Result;
}
extern "C" {
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_SetLcdForceBlack(flags: u8_) -> Result;
}
extern "C" {
    pub fn GSPGPU_SetBufferSwap(
        screenid: u32_,
        framebufinfo: *const GSPGPU_FramebufferInfo,
    ) -> Result;
}
extern "C" {
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegs(regAddr: u32_, data: *const u32_, size: u8_) -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegsWithMask(
        regAddr: u32_,
        data: *const u32_,
        datasize: u8_,
        maskdata: *const u32_,
        masksize: u8_,
    ) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReadHWRegs(regAddr: u32_, data: *mut u32_, size: u8_) -> Result;
}
extern "C" {
    pub fn GSPGPU_RegisterInterruptRelayQueue(
        eventHandle: Handle,
        flags: u32_,
        outMemHandle: *mut Handle,
        threadID: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
extern "C" {
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
extern "C" {
    pub fn GSPGPU_SetLedForceOff(disable: bool) -> Result;
}
pub const GFX_TOP: gfxScreen_t = 0;
pub const GFX_BOTTOM: gfxScreen_t = 1;
pub type gfxScreen_t = ::libc::c_uint;
pub const GFX_LEFT: gfx3dSide_t = 0;
pub const GFX_RIGHT: gfx3dSide_t = 1;
pub type gfx3dSide_t = ::libc::c_uint;
extern "C" {
    pub fn gfxInitDefault();
}
extern "C" {
    pub fn gfxInit(
        topFormat: GSPGPU_FramebufferFormat,
        bottomFormat: GSPGPU_FramebufferFormat,
        vrambuffers: bool,
    );
}
extern "C" {
    pub fn gfxExit();
}
extern "C" {
    pub fn gfxSet3D(enable: bool);
}
extern "C" {
    pub fn gfxIs3D() -> bool;
}
extern "C" {
    pub fn gfxIsWide() -> bool;
}
extern "C" {
    pub fn gfxSetWide(enable: bool);
}
extern "C" {
    pub fn gfxSetScreenFormat(screen: gfxScreen_t, format: GSPGPU_FramebufferFormat);
}
extern "C" {
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSPGPU_FramebufferFormat;
}
extern "C" {
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, enable: bool);
}
extern "C" {
    pub fn gfxGetFramebuffer(
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        width: *mut u16_,
        height: *mut u16_,
    ) -> *mut u8_;
}
extern "C" {
    pub fn gfxFlushBuffers();
}
extern "C" {
    pub fn gfxScreenSwapBuffers(scr: gfxScreen_t, hasStereo: bool);
}
extern "C" {
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
extern "C" {
    pub fn gfxSwapBuffers();
}
extern "C" {
    pub fn gfxSwapBuffersGpu();
}
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_int) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleFont {
    pub gfx: *mut u8_,
    pub asciiOffset: u16_,
    pub numChars: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintConsole {
    pub font: ConsoleFont,
    pub frameBuffer: *mut u16_,
    pub cursorX: ::libc::c_int,
    pub cursorY: ::libc::c_int,
    pub prevCursorX: ::libc::c_int,
    pub prevCursorY: ::libc::c_int,
    pub consoleWidth: ::libc::c_int,
    pub consoleHeight: ::libc::c_int,
    pub windowX: ::libc::c_int,
    pub windowY: ::libc::c_int,
    pub windowWidth: ::libc::c_int,
    pub windowHeight: ::libc::c_int,
    pub tabSize: ::libc::c_int,
    pub fg: u16_,
    pub bg: u16_,
    pub flags: ::libc::c_int,
    pub PrintChar: ConsolePrint,
    pub consoleInitialised: bool,
}
pub const debugDevice_NULL: debugDevice = 0;
pub const debugDevice_SVC: debugDevice = 1;
pub const debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_3DMOO: debugDevice = 1;
pub type debugDevice = ::libc::c_uint;
extern "C" {
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
extern "C" {
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    pub fn consoleClear();
}
pub const RUNFLAG_APTWORKAROUND: ::libc::c_uint = 1;
pub const RUNFLAG_APTREINIT: ::libc::c_uint = 2;
pub const RUNFLAG_APTCHAINLOAD: ::libc::c_uint = 4;
pub type _bindgen_ty_9 = ::libc::c_uint;
extern "C" {
    pub fn envGetHandle(name: *const ::libc::c_char) -> Handle;
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type wint_t = ::libc::c_int;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_uint;
pub type _ssize_t = ::libc::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = ::libc::c_long;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
pub const DECOMPRESS_DUMMY: decompressType = 0;
pub const DECOMPRESS_LZSS: decompressType = 16;
pub const DECOMPRESS_LZ10: decompressType = 16;
pub const DECOMPRESS_LZ11: decompressType = 17;
pub const DECOMPRESS_HUFF1: decompressType = 33;
pub const DECOMPRESS_HUFF2: decompressType = 34;
pub const DECOMPRESS_HUFF3: decompressType = 35;
pub const DECOMPRESS_HUFF4: decompressType = 36;
pub const DECOMPRESS_HUFF5: decompressType = 37;
pub const DECOMPRESS_HUFF6: decompressType = 38;
pub const DECOMPRESS_HUFF7: decompressType = 39;
pub const DECOMPRESS_HUFF8: decompressType = 40;
pub const DECOMPRESS_HUFF: decompressType = 40;
pub const DECOMPRESS_RLE: decompressType = 48;
pub type decompressType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decompressIOVec {
    pub data: *mut ::libc::c_void,
    pub size: size_t,
}
pub type decompressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: size_t,
    ) -> ssize_t,
>;
extern "C" {
    pub fn decompressCallback_FD(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn decompressCallback_Stdio(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn decompressHeader(
        type_: *mut decompressType,
        size: *mut size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn decompressV(
        iov: *const decompressIOVec,
        iovcnt: size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_LZSS(
        iov: *const decompressIOVec,
        iovcnt: size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_LZ11(
        iov: *const decompressIOVec,
        iovcnt: size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_Huff(
        bits: size_t,
        iov: *const decompressIOVec,
        iovcnt: size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn decompressV_RLE(
        iov: *const decompressIOVec,
        iovcnt: size_t,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: size_t,
    ) -> bool;
}
extern "C" {
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> ssize_t;
}
extern "C" {
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> ssize_t;
}
extern "C" {
    pub fn encode_utf8(out: *mut u8, in_: u32) -> ssize_t;
}
extern "C" {
    pub fn encode_utf16(out: *mut u16, in_: u32) -> ssize_t;
}
extern "C" {
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: size_t) -> ssize_t;
}
extern "C" {
    pub fn linearAlloc(size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearMemAlign(size: size_t, alignment: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> size_t;
}
extern "C" {
    pub fn linearFree(mem: *mut ::libc::c_void);
}
extern "C" {
    pub fn linearSpaceFree() -> u32_;
}
extern "C" {
    pub fn mappableInit(addrMin: u32_, addrMax: u32_);
}
extern "C" {
    pub fn mappableAlloc(size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn mappableFree(mem: *mut ::libc::c_void);
}
pub const VRAM_ALLOC_A: vramAllocPos = 1;
pub const VRAM_ALLOC_B: vramAllocPos = 2;
pub const VRAM_ALLOC_ANY: vramAllocPos = 3;
pub type vramAllocPos = ::libc::c_uint;
extern "C" {
    pub fn vramAlloc(size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramAllocAt(size: size_t, pos: vramAllocPos) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramMemAlign(size: size_t, alignment: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramMemAlignAt(
        size: size_t,
        alignment: size_t,
        pos: vramAllocPos,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: size_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn vramGetSize(mem: *mut ::libc::c_void) -> size_t;
}
extern "C" {
    pub fn vramFree(mem: *mut ::libc::c_void);
}
extern "C" {
    pub fn vramSpaceFree() -> u32_;
}
pub const AC_OPEN: acSecurityMode = 0;
pub const AC_WEP_40BIT: acSecurityMode = 1;
pub const AC_WEP_104BIT: acSecurityMode = 2;
pub const AC_WEP_128BIT: acSecurityMode = 3;
pub const AC_WPA_TKIP: acSecurityMode = 4;
pub const AC_WPA2_TKIP: acSecurityMode = 5;
pub const AC_WPA_AES: acSecurityMode = 6;
pub const AC_WPA2_AES: acSecurityMode = 7;
pub type acSecurityMode = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acuConfig {
    pub reserved: [u8_; 512usize],
}
extern "C" {
    pub fn acInit() -> Result;
}
extern "C" {
    pub fn acExit();
}
extern "C" {
    pub fn acWaitInternetConnection() -> Result;
}
extern "C" {
    pub fn ACU_GetWifiStatus(out: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_GetStatus(out: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_GetSecurityMode(mode: *mut acSecurityMode) -> Result;
}
extern "C" {
    pub fn ACU_GetSSID(SSID: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetSSIDLength(out: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyEnable(enable: *mut bool) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyPort(out: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyUserName(username: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetProxyPassword(password: *mut ::libc::c_char) -> Result;
}
extern "C" {
    pub fn ACU_GetLastErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_GetLastDetailErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    pub fn ACU_CreateDefaultConfig(config: *mut acuConfig) -> Result;
}
extern "C" {
    pub fn ACU_SetNetworkArea(config: *mut acuConfig, area: u8_) -> Result;
}
extern "C" {
    pub fn ACU_SetAllowApType(config: *mut acuConfig, type_: u8_) -> Result;
}
extern "C" {
    pub fn ACU_SetRequestEulaVersion(config: *mut acuConfig) -> Result;
}
extern "C" {
    pub fn ACU_ConnectAsync(config: *const acuConfig, connectionHandle: Handle) -> Result;
}
pub const FS_OPEN_READ: ::libc::c_uint = 1;
pub const FS_OPEN_WRITE: ::libc::c_uint = 2;
pub const FS_OPEN_CREATE: ::libc::c_uint = 4;
pub type _bindgen_ty_10 = ::libc::c_uint;
pub const FS_WRITE_FLUSH: ::libc::c_uint = 1;
pub const FS_WRITE_UPDATE_TIME: ::libc::c_uint = 256;
pub type _bindgen_ty_11 = ::libc::c_uint;
pub const FS_ATTRIBUTE_DIRECTORY: ::libc::c_uint = 1;
pub const FS_ATTRIBUTE_HIDDEN: ::libc::c_uint = 256;
pub const FS_ATTRIBUTE_ARCHIVE: ::libc::c_uint = 65536;
pub const FS_ATTRIBUTE_READ_ONLY: ::libc::c_uint = 16777216;
pub type _bindgen_ty_12 = ::libc::c_uint;
pub const MEDIATYPE_NAND: FS_MediaType = 0;
pub const MEDIATYPE_SD: FS_MediaType = 1;
pub const MEDIATYPE_GAME_CARD: FS_MediaType = 2;
pub type FS_MediaType = ::libc::c_uint;
pub const SYSTEM_MEDIATYPE_CTR_NAND: FS_SystemMediaType = 0;
pub const SYSTEM_MEDIATYPE_TWL_NAND: FS_SystemMediaType = 1;
pub const SYSTEM_MEDIATYPE_SD: FS_SystemMediaType = 2;
pub const SYSTEM_MEDIATYPE_TWL_PHOTO: FS_SystemMediaType = 3;
pub type FS_SystemMediaType = ::libc::c_uint;
pub const ARCHIVE_ROMFS: FS_ArchiveID = 3;
pub const ARCHIVE_SAVEDATA: FS_ArchiveID = 4;
pub const ARCHIVE_EXTDATA: FS_ArchiveID = 6;
pub const ARCHIVE_SHARED_EXTDATA: FS_ArchiveID = 7;
pub const ARCHIVE_SYSTEM_SAVEDATA: FS_ArchiveID = 8;
pub const ARCHIVE_SDMC: FS_ArchiveID = 9;
pub const ARCHIVE_SDMC_WRITE_ONLY: FS_ArchiveID = 10;
pub const ARCHIVE_BOSS_EXTDATA: FS_ArchiveID = 305419896;
pub const ARCHIVE_CARD_SPIFS: FS_ArchiveID = 305419897;
pub const ARCHIVE_EXTDATA_AND_BOSS_EXTDATA: FS_ArchiveID = 305419899;
pub const ARCHIVE_SYSTEM_SAVEDATA2: FS_ArchiveID = 305419900;
pub const ARCHIVE_NAND_RW: FS_ArchiveID = 305419901;
pub const ARCHIVE_NAND_RO: FS_ArchiveID = 305419902;
pub const ARCHIVE_NAND_RO_WRITE_ACCESS: FS_ArchiveID = 305419903;
pub const ARCHIVE_SAVEDATA_AND_CONTENT: FS_ArchiveID = 591751050;
pub const ARCHIVE_SAVEDATA_AND_CONTENT2: FS_ArchiveID = 591751054;
pub const ARCHIVE_NAND_CTR_FS: FS_ArchiveID = 1450741931;
pub const ARCHIVE_TWL_PHOTO: FS_ArchiveID = 1450741932;
pub const ARCHIVE_TWL_SOUND: FS_ArchiveID = 1450741933;
pub const ARCHIVE_NAND_TWL_FS: FS_ArchiveID = 1450741934;
pub const ARCHIVE_NAND_W_FS: FS_ArchiveID = 1450741935;
pub const ARCHIVE_GAMECARD_SAVEDATA: FS_ArchiveID = 1450741937;
pub const ARCHIVE_USER_SAVEDATA: FS_ArchiveID = 1450741938;
pub const ARCHIVE_DEMO_SAVEDATA: FS_ArchiveID = 1450741940;
pub type FS_ArchiveID = ::libc::c_uint;
pub const PATH_INVALID: FS_PathType = 0;
pub const PATH_EMPTY: FS_PathType = 1;
pub const PATH_BINARY: FS_PathType = 2;
pub const PATH_ASCII: FS_PathType = 3;
pub const PATH_UTF16: FS_PathType = 4;
pub type FS_PathType = ::libc::c_uint;
pub const SECUREVALUE_SLOT_SD: FS_SecureValueSlot = 4096;
pub type FS_SecureValueSlot = ::libc::c_uint;
pub const BAUDRATE_512KHZ: FS_CardSpiBaudRate = 0;
pub const BAUDRATE_1MHZ: FS_CardSpiBaudRate = 1;
pub const BAUDRATE_2MHZ: FS_CardSpiBaudRate = 2;
pub const BAUDRATE_4MHZ: FS_CardSpiBaudRate = 3;
pub const BAUDRATE_8MHZ: FS_CardSpiBaudRate = 4;
pub const BAUDRATE_16MHZ: FS_CardSpiBaudRate = 5;
pub type FS_CardSpiBaudRate = ::libc::c_uint;
pub const BUSMODE_1BIT: FS_CardSpiBusMode = 0;
pub const BUSMODE_4BIT: FS_CardSpiBusMode = 1;
pub type FS_CardSpiBusMode = ::libc::c_uint;
pub const SPECIALCONTENT_UPDATE: FS_SpecialContentType = 1;
pub const SPECIALCONTENT_MANUAL: FS_SpecialContentType = 2;
pub const SPECIALCONTENT_DLP_CHILD: FS_SpecialContentType = 3;
pub type FS_SpecialContentType = ::libc::c_uint;
pub const CARD_CTR: FS_CardType = 0;
pub const CARD_TWL: FS_CardType = 1;
pub type FS_CardType = ::libc::c_uint;
pub const FS_ACTION_UNKNOWN: FS_Action = 0;
pub type FS_Action = ::libc::c_uint;
pub const ARCHIVE_ACTION_COMMIT_SAVE_DATA: FS_ArchiveAction = 0;
pub const ARCHIVE_ACTION_GET_TIMESTAMP: FS_ArchiveAction = 1;
pub const ARCHIVE_ACTION_UNKNOWN: FS_ArchiveAction = 30877;
pub type FS_ArchiveAction = ::libc::c_uint;
pub const SECURESAVE_ACTION_DELETE: FS_SecureSaveAction = 0;
pub const SECURESAVE_ACTION_FORMAT: FS_SecureSaveAction = 1;
pub type FS_SecureSaveAction = ::libc::c_uint;
pub const FILE_ACTION_UNKNOWN: FS_FileAction = 0;
pub type FS_FileAction = ::libc::c_uint;
pub const DIRECTORY_ACTION_UNKNOWN: FS_DirectoryAction = 0;
pub type FS_DirectoryAction = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_DirectoryEntry {
    pub name: [u16_; 262usize],
    pub shortName: [::libc::c_char; 10usize],
    pub shortExt: [::libc::c_char; 4usize],
    pub valid: u8_,
    pub reserved: u8_,
    pub attributes: u32_,
    pub fileSize: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ArchiveResource {
    pub sectorSize: u32_,
    pub clusterSize: u32_,
    pub totalClusters: u32_,
    pub freeClusters: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ProgramInfo {
    pub programId: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub padding: [u8_; 7usize],
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ProductInfo {
    pub productCode: [::libc::c_char; 16usize],
    pub companyCode: [::libc::c_char; 2usize],
    pub remasterVersion: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_IntegrityVerificationSeed {
    pub aesCbcMac: [u8_; 16usize],
    pub movableSed: [u8_; 288usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub unknown: u8_,
    pub reserved1: u16_,
    pub saveId: u64_,
    pub reserved2: u32_,
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub unknown: u8_,
    pub reserved: u16_,
    pub saveId: u32_,
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_DeviceMoveContext {
    pub ivs: [u8_; 16usize],
    pub encryptParameter: [u8_; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_Path {
    pub type_: FS_PathType,
    pub size: u32_,
    pub data: *const ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SdMmcSpeedInfo {
    pub highSpeedModeEnabled: bool,
    pub usesHighestClockRate: bool,
    pub sdClkCtrl: u16_,
}
pub type FS_Archive = u64_;
extern "C" {
    pub fn fsInit() -> Result;
}
extern "C" {
    pub fn fsExit();
}
extern "C" {
    pub fn fsUseSession(session: Handle);
}
extern "C" {
    pub fn fsEndUseSession();
}
extern "C" {
    pub fn fsExemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void) -> FS_Path;
}
extern "C" {
    pub fn fsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn FSUSER_Control(
        action: FS_Action,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFile(
        out: *mut Handle,
        archive: FS_Archive,
        path: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFileDirectly(
        out: *mut Handle,
        archiveId: FS_ArchiveID,
        archivePath: FS_Path,
        filePath: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameFile(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateFile(
        archive: FS_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path, attributes: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameDirectory(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlArchive(
        archive: FS_Archive,
        action: FS_ArchiveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64_, archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
extern "C" {
    pub fn FSUSER_ClearNandLog() -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommand(commandId: u8_) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8_, address: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead(
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectReadWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWrite(
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWriteWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead_4xIO(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo, processId: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialContentIndex(
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader(
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyBannerData(
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(
        access: *mut bool,
        mediaType: FS_MediaType,
        saveId: u64_,
        processId: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_QueryTotalQuotaSize(
        quotaSize: *mut u64_,
        directories: u32_,
        files: u32_,
        fileSizeCount: u32_,
        fileSizes: *mut u64_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSeed() -> Result;
}
extern "C" {
    pub fn FSUSER_GetFormatInfo(
        totalSize: *mut u32_,
        directories: *mut u32_,
        files: *mut u32_,
        duplicateData: *mut bool,
        archiveId: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader2(
        headerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchiveResource(
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ExportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ImportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_FormatSaveData(
        archiveId: FS_ArchiveID,
        path: FS_Path,
        blocks: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacySubBannerData(
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_UpdateSha256Context(
        data: *const ::libc::c_void,
        inputSize: u32_,
        hash: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ReadSpecialFile(
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64_) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateExtSaveData(
        info: FS_ExtSaveDataInfo,
        directories: u32_,
        files: u32_,
        sizeLimit: u64_,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_ReadExtSaveDataIcon(
        bytesRead: *mut u32_,
        info: FS_ExtSaveDataInfo,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetExtDataBlockSize(
        totalBlocks: *mut u64_,
        freeBlocks: *mut u64_,
        blockSize: *mut u32_,
        info: FS_ExtSaveDataInfo,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateExtSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSystemSaveData(
        info: FS_SystemSaveDataInfo,
        totalSize: u32_,
        blockSize: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext) -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsDestination(
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchivePriority(priority: *mut u32_, archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64_, emulateEndurance: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateSystemSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_SetPriority(priority: u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_GetPriority(priority: *mut u32_) -> Result;
}
extern "C" {
    pub fn FSUSER_SetSaveDataSecureValue(
        value: u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSaveDataSecureValue(
        exists: *mut bool,
        value: *mut u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlSecureSave(
        action: FS_SecureSaveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
extern "C" {
    pub fn FSFILE_Control(
        handle: Handle,
        action: FS_FileAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_OpenSubFile(
        handle: Handle,
        subFile: *mut Handle,
        offset: u64_,
        size: u64_,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_Read(
        handle: Handle,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_Write(
        handle: Handle,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64_) -> Result;
}
extern "C" {
    pub fn FSFILE_SetSize(handle: Handle, size: u64_) -> Result;
}
extern "C" {
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32_) -> Result;
}
extern "C" {
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32_) -> Result;
}
extern "C" {
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
extern "C" {
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle) -> Result;
}
extern "C" {
    pub fn FSDIR_Control(
        handle: Handle,
        action: FS_DirectoryAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSDIR_Read(
        handle: Handle,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AM_TitleEntry {
    pub titleID: u64_,
    pub size: u64_,
    pub version: u16_,
    pub unk: [u8_; 6usize],
}
pub const AM_STATUS_MASK_INSTALLING: ::libc::c_uint = 1;
pub const AM_STATUS_MASK_AWAITING_FINALIZATION: ::libc::c_uint = 2;
pub type _bindgen_ty_13 = ::libc::c_uint;
pub const AM_STATUS_ABORTED: AM_InstallStatus = 2;
pub const AM_STATUS_SAVED: AM_InstallStatus = 3;
pub const AM_STATUS_INSTALL_IN_PROGRESS: AM_InstallStatus = 2050;
pub const AM_STATUS_AWAITING_FINALIZATION: AM_InstallStatus = 2051;
pub type AM_InstallStatus = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AM_PendingTitleEntry {
    pub titleId: u64_,
    pub version: u16_,
    pub status: u16_,
    pub titleType: u32_,
    pub unk: [u8_; 8usize],
}
pub const AM_DELETE_PENDING_NON_SYSTEM: ::libc::c_uint = 1;
pub const AM_DELETE_PENDING_SYSTEM: ::libc::c_uint = 2;
pub type _bindgen_ty_14 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AM_TWLPartitionInfo {
    pub capacity: u64_,
    pub freeSpace: u64_,
    pub titlesCapacity: u64_,
    pub titlesFreeSpace: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AM_ContentInfo {
    pub index: u16_,
    pub type_: u16_,
    pub contentId: u32_,
    pub size: u64_,
    pub flags: u8_,
    pub padding: [u8_; 7usize],
}
pub const AM_CONTENT_DOWNLOADED: AM_ContentInfoFlags = 1;
pub const AM_CONTENT_OWNED: AM_ContentInfoFlags = 2;
pub type AM_ContentInfoFlags = ::libc::c_uint;
extern "C" {
    pub fn amInit() -> Result;
}
extern "C" {
    pub fn amAppInit() -> Result;
}
extern "C" {
    pub fn amExit();
}
extern "C" {
    pub fn amGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32_) -> Result;
}
extern "C" {
    pub fn AM_GetTitleList(
        titlesRead: *mut u32_,
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTitleInfo(
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
        titleInfo: *mut AM_TitleEntry,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTicketCount(count: *mut u32_) -> Result;
}
extern "C" {
    pub fn AM_GetTicketList(
        ticketsRead: *mut u32_,
        ticketCount: u32_,
        skip: u32_,
        ticketIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleList(
        titlesRead: *mut u32_,
        titleCount: u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleInfo(
        titleCount: u32_,
        mediatype: FS_MediaType,
        titleIds: *mut u64_,
        titleInfo: *mut AM_PendingTitleEntry,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetDeviceId(deviceID: *mut u32_) -> Result;
}
extern "C" {
    pub fn AM_ExportTwlBackup(
        titleID: u64_,
        operation: u8_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        filepath: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn AM_ImportTwlBackup(
        filehandle: Handle,
        operation: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn AM_ReadTwlBackupInfo(
        filehandle: Handle,
        outinfo: *mut ::libc::c_void,
        outinfo_size: u32_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        banner: *mut ::libc::c_void,
        banner_size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
extern "C" {
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_CommitImportPrograms(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    pub fn AM_DeleteTicket(ticketId: u64_) -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32_) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    pub fn AM_InstallNativeFirm() -> Result;
}
extern "C" {
    pub fn AM_InstallFirm(titleID: u64_) -> Result;
}
extern "C" {
    pub fn AM_GetTitleProductCode(
        mediatype: FS_MediaType,
        titleId: u64_,
        productCode: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetTitleExtDataId(
        extDataId: *mut u64_,
        mediatype: FS_MediaType,
        titleId: u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaFileInfo(
        mediatype: FS_MediaType,
        titleEntry: *mut AM_TitleEntry,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaIcon(icon: *mut ::libc::c_void, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaDependencies(dependencies: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32_, fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaRequiredSpace(
        requiredSpace: *mut u64_,
        mediaType: FS_MediaType,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaSection(
        meta: *mut ::libc::c_void,
        size: u32_,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
extern "C" {
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64_, unk: bool) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleStop() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleAbort() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleFinish() -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitles(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
extern "C" {
    pub fn AM_CreateImportContentContexts(contentCount: u32_, contentIndices: *mut u16_) -> Result;
}
extern "C" {
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16_) -> Result;
}
extern "C" {
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentResume(
        contentHandle: *mut Handle,
        resumeOffset: *mut u64_,
        index: u16_,
    ) -> Result;
}
extern "C" {
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_ImportCertificates(
        cert1Size: u32_,
        cert1: *mut ::libc::c_void,
        cert2Size: u32_,
        cert2: *mut ::libc::c_void,
        cert3Size: u32_,
        cert3: *mut ::libc::c_void,
        cert4Size: u32_,
        cert4: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn AM_ImportCertificate(certSize: u32_, cert: *mut ::libc::c_void) -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
extern "C" {
    pub fn AM_DeleteAllTemporaryTitles() -> Result;
}
extern "C" {
    pub fn AM_DeleteAllExpiredTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    pub fn AM_DeleteAllTwlTitles() -> Result;
}
extern "C" {
    pub fn AMAPP_GetDLCContentInfoCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
    ) -> Result;
}
extern "C" {
    pub fn AMAPP_ListDLCContentInfos(
        contentInfoRead: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
        contentInfoCount: u32_,
        offset: u32_,
        contentInfos: *mut AM_ContentInfo,
    ) -> Result;
}
extern "C" {
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
extern "C" {
    pub fn ampxiExit();
}
extern "C" {
    pub fn AMPXI_WriteTWLSavedata(
        titleid: u64_,
        buffer: *mut u8_,
        size: u32_,
        image_filepos: u32_,
        section_type: u8_,
        operation: u8_,
    ) -> Result;
}
extern "C" {
    pub fn AMPXI_InstallTitlesFinish(
        mediaType: FS_MediaType,
        db: u8_,
        titlecount: u32_,
        tidlist: *mut u64_,
    ) -> Result;
}
pub const APPID_NONE: NS_APPID = 0;
pub const APPID_HOMEMENU: NS_APPID = 257;
pub const APPID_CAMERA: NS_APPID = 272;
pub const APPID_FRIENDS_LIST: NS_APPID = 274;
pub const APPID_GAME_NOTES: NS_APPID = 275;
pub const APPID_WEB: NS_APPID = 276;
pub const APPID_INSTRUCTION_MANUAL: NS_APPID = 277;
pub const APPID_NOTIFICATIONS: NS_APPID = 278;
pub const APPID_MIIVERSE: NS_APPID = 279;
pub const APPID_MIIVERSE_POSTING: NS_APPID = 280;
pub const APPID_AMIIBO_SETTINGS: NS_APPID = 281;
pub const APPID_APPLICATION: NS_APPID = 768;
pub const APPID_ESHOP: NS_APPID = 769;
pub const APPID_SOFTWARE_KEYBOARD: NS_APPID = 1025;
pub const APPID_APPLETED: NS_APPID = 1026;
pub const APPID_PNOTE_AP: NS_APPID = 1028;
pub const APPID_SNOTE_AP: NS_APPID = 1029;
pub const APPID_ERROR: NS_APPID = 1030;
pub const APPID_MINT: NS_APPID = 1031;
pub const APPID_EXTRAPAD: NS_APPID = 1032;
pub const APPID_MEMOLIB: NS_APPID = 1033;
pub type NS_APPID = ::libc::c_uint;
pub const APTPOS_NONE: APT_AppletPos = -1;
pub const APTPOS_APP: APT_AppletPos = 0;
pub const APTPOS_APPLIB: APT_AppletPos = 1;
pub const APTPOS_SYS: APT_AppletPos = 2;
pub const APTPOS_SYSLIB: APT_AppletPos = 3;
pub const APTPOS_RESIDENT: APT_AppletPos = 4;
pub type APT_AppletPos = ::libc::c_int;
pub type APT_AppletAttr = u8_;
pub const APTREPLY_REJECT: APT_QueryReply = 0;
pub const APTREPLY_ACCEPT: APT_QueryReply = 1;
pub const APTREPLY_LATER: APT_QueryReply = 2;
pub type APT_QueryReply = ::libc::c_uint;
pub const APTSIGNAL_NONE: APT_Signal = 0;
pub const APTSIGNAL_HOMEBUTTON: APT_Signal = 1;
pub const APTSIGNAL_HOMEBUTTON2: APT_Signal = 2;
pub const APTSIGNAL_SLEEP_QUERY: APT_Signal = 3;
pub const APTSIGNAL_SLEEP_CANCEL: APT_Signal = 4;
pub const APTSIGNAL_SLEEP_ENTER: APT_Signal = 5;
pub const APTSIGNAL_SLEEP_WAKEUP: APT_Signal = 6;
pub const APTSIGNAL_SHUTDOWN: APT_Signal = 7;
pub const APTSIGNAL_POWERBUTTON: APT_Signal = 8;
pub const APTSIGNAL_POWERBUTTON2: APT_Signal = 9;
pub const APTSIGNAL_TRY_SLEEP: APT_Signal = 10;
pub const APTSIGNAL_ORDERTOCLOSE: APT_Signal = 11;
pub type APT_Signal = ::libc::c_uint;
pub const APTCMD_NONE: APT_Command = 0;
pub const APTCMD_WAKEUP: APT_Command = 1;
pub const APTCMD_REQUEST: APT_Command = 2;
pub const APTCMD_RESPONSE: APT_Command = 3;
pub const APTCMD_EXIT: APT_Command = 4;
pub const APTCMD_MESSAGE: APT_Command = 5;
pub const APTCMD_HOMEBUTTON_ONCE: APT_Command = 6;
pub const APTCMD_HOMEBUTTON_TWICE: APT_Command = 7;
pub const APTCMD_DSP_SLEEP: APT_Command = 8;
pub const APTCMD_DSP_WAKEUP: APT_Command = 9;
pub const APTCMD_WAKEUP_EXIT: APT_Command = 10;
pub const APTCMD_WAKEUP_PAUSE: APT_Command = 11;
pub const APTCMD_WAKEUP_CANCEL: APT_Command = 12;
pub const APTCMD_WAKEUP_CANCELALL: APT_Command = 13;
pub const APTCMD_WAKEUP_POWERBUTTON: APT_Command = 14;
pub const APTCMD_WAKEUP_JUMPTOHOME: APT_Command = 15;
pub const APTCMD_SYSAPPLET_REQUEST: APT_Command = 16;
pub const APTCMD_WAKEUP_LAUNCHAPP: APT_Command = 17;
pub type APT_Command = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aptCaptureBufInfo {
    pub size: u32_,
    pub is3D: u32_,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32_,
    pub rightOffset: u32_,
    pub format: u32_,
}
pub const APTHOOK_ONSUSPEND: APT_HookType = 0;
pub const APTHOOK_ONRESTORE: APT_HookType = 1;
pub const APTHOOK_ONSLEEP: APT_HookType = 2;
pub const APTHOOK_ONWAKEUP: APT_HookType = 3;
pub const APTHOOK_ONEXIT: APT_HookType = 4;
pub const APTHOOK_COUNT: APT_HookType = 5;
pub type APT_HookType = ::libc::c_uint;
pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType, param: *mut ::libc::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_aptHookCookie {
    pub next: *mut tag_aptHookCookie,
    pub callback: aptHookFn,
    pub param: *mut ::libc::c_void,
}
pub type aptHookCookie = tag_aptHookCookie;
pub type aptMessageCb = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        sender: NS_APPID,
        msg: *mut ::libc::c_void,
        msgsize: size_t,
    ),
>;
extern "C" {
    pub fn aptInit() -> Result;
}
extern "C" {
    pub fn aptExit();
}
extern "C" {
    pub fn aptSendCommand(aptcmdbuf: *mut u32_) -> Result;
}
extern "C" {
    pub fn aptIsActive() -> bool;
}
extern "C" {
    pub fn aptShouldClose() -> bool;
}
extern "C" {
    pub fn aptIsSleepAllowed() -> bool;
}
extern "C" {
    pub fn aptSetSleepAllowed(allowed: bool);
}
extern "C" {
    pub fn aptHandleSleep();
}
extern "C" {
    pub fn aptIsHomeAllowed() -> bool;
}
extern "C" {
    pub fn aptSetHomeAllowed(allowed: bool);
}
extern "C" {
    pub fn aptShouldJumpToHome() -> bool;
}
extern "C" {
    pub fn aptCheckHomePressRejected() -> bool;
}
extern "C" {
    pub fn aptJumpToHomeMenu();
}
extern "C" {
    pub fn aptMainLoop() -> bool;
}
extern "C" {
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn, param: *mut ::libc::c_void);
}
extern "C" {
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
extern "C" {
    pub fn aptSetMessageCallback(callback: aptMessageCb, user: *mut ::libc::c_void);
}
extern "C" {
    pub fn aptLaunchLibraryApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: size_t,
        handle: Handle,
    );
}
extern "C" {
    pub fn aptClearChainloader();
}
extern "C" {
    pub fn aptSetChainloader(programID: u64_, mediatype: u8_);
}
extern "C" {
    pub fn aptSetChainloaderToSelf();
}
extern "C" {
    pub fn APT_GetLockHandle(flags: u16_, lockHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn APT_Initialize(
        appId: NS_APPID,
        attr: APT_AppletAttr,
        signalEvent: *mut Handle,
        resumeEvent: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_HardwareResetAsync() -> Result;
}
extern "C" {
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
extern "C" {
    pub fn APT_GetAppletManInfo(
        inpos: APT_AppletPos,
        outpos: *mut APT_AppletPos,
        req_appid: *mut NS_APPID,
        menu_appid: *mut NS_APPID,
        active_appid: *mut NS_APPID,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetAppletInfo(
        appID: NS_APPID,
        pProgramID: *mut u64_,
        pMediaType: *mut u8_,
        pRegistered: *mut bool,
        pLoadState: *mut bool,
        pAttributes: *mut APT_AppletAttr,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetAppletProgramInfo(id: u32_, flags: u32_, titleversion: *mut u16_) -> Result;
}
extern "C" {
    pub fn APT_GetProgramID(pProgramID: *mut u64_) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
extern "C" {
    pub fn APT_JumpToHomeMenu(
        param: *const ::libc::c_void,
        paramSize: size_t,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
extern "C" {
    pub fn APT_JumpToApplication(
        param: *const ::libc::c_void,
        paramSize: size_t,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_InquireNotification(appID: u32_, signalType: *mut APT_Signal) -> Result;
}
extern "C" {
    pub fn APT_SleepSystem(wakeEvents: *const PtmWakeEvents) -> Result;
}
extern "C" {
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_AppletUtility(
        id: ::libc::c_int,
        out: *mut ::libc::c_void,
        outSize: size_t,
        in_: *const ::libc::c_void,
        inSize: size_t,
    ) -> Result;
}
extern "C" {
    pub fn APT_SleepIfShellClosed() -> Result;
}
extern "C" {
    pub fn APT_LockTransition(transition: u32_, flag: bool) -> Result;
}
extern "C" {
    pub fn APT_TryLockTransition(transition: u32_, succeeded: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_UnlockTransition(transition: u32_) -> Result;
}
extern "C" {
    pub fn APT_GlanceParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: size_t,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut size_t,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_ReceiveParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: size_t,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut size_t,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_SendParameter(
        source: NS_APPID,
        dest: NS_APPID,
        command: APT_Command,
        buffer: *const ::libc::c_void,
        bufferSize: u32_,
        parameter: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID, success: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo) -> Result;
}
extern "C" {
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply) -> Result;
}
extern "C" {
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
extern "C" {
    pub fn APT_CloseApplication(
        param: *const ::libc::c_void,
        paramSize: size_t,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_SetAppCpuTimeLimit(percent: u32_) -> Result;
}
extern "C" {
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32_) -> Result;
}
extern "C" {
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_PrepareToDoApplicationJump(flags: u8_, programID: u64_, mediatype: u8_) -> Result;
}
extern "C" {
    pub fn APT_DoApplicationJump(
        param: *const ::libc::c_void,
        paramSize: size_t,
        hmac: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartLibraryApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: size_t,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartSystemApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: size_t,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32_) -> Result;
}
extern "C" {
    pub fn APT_ReceiveDeliverArg(
        param: *const ::libc::c_void,
        paramSize: size_t,
        hmac: *const ::libc::c_void,
        sender: *mut u64_,
        received: *mut bool,
    ) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bossContext {
    pub property: [u32_; 7usize],
    pub url: [::libc::c_char; 512usize],
    pub property_x8: u32_,
    pub property_x9: u8_,
    pub property_xa: [u8_; 256usize],
    pub property_xb: [u8_; 512usize],
    pub property_xd: [::libc::c_char; 864usize],
    pub property_xe: u32_,
    pub property_xf: [u32_; 3usize],
    pub property_x10: u8_,
    pub property_x11: u8_,
    pub property_x12: u8_,
    pub property_x13: u32_,
    pub property_x14: u32_,
    pub property_x15: [u8_; 64usize],
    pub property_x16: u32_,
    pub property_x3b: u32_,
    pub property_x3e: [u8_; 512usize],
}
pub const BOSSTASKSTATUS_STARTED: bossTaskStatus = 2;
pub const BOSSTASKSTATUS_ERROR: bossTaskStatus = 7;
pub type bossTaskStatus = ::libc::c_uint;
pub const bossNsDataHeaderInfoType_ContentSize: bossNsDataHeaderInfoTypes = 3;
pub type bossNsDataHeaderInfoTypes = ::libc::c_uint;
pub const bossNsDataHeaderInfoTypeSize_ContentSize: bossNsDataHeaderInfoTypeSizes = 4;
pub type bossNsDataHeaderInfoTypeSizes = ::libc::c_uint;
extern "C" {
    pub fn bossInit(programID: u64_, force_user: bool) -> Result;
}
extern "C" {
    pub fn bossReinit(programID: u64_) -> Result;
}
extern "C" {
    pub fn bossExit();
}
extern "C" {
    pub fn bossGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn bossSetStorageInfo(extdataID: u64_, boss_size: u32_, mediaType: u8_) -> Result;
}
extern "C" {
    pub fn bossUnregisterStorage() -> Result;
}
extern "C" {
    pub fn bossRegisterTask(taskID: *const ::libc::c_char, unk0: u8_, unk1: u8_) -> Result;
}
extern "C" {
    pub fn bossSendProperty(PropertyID: u16_, buf: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn bossDeleteNsData(NsDataId: u32_) -> Result;
}
extern "C" {
    pub fn bossGetNsDataHeaderInfo(
        NsDataId: u32_,
        type_: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn bossReadNsData(
        NsDataId: u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
        transfer_total: *mut u32_,
        unk_out: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn bossStartTaskImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn bossStartBgImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn bossDeleteTask(taskID: *const ::libc::c_char, unk: u32_) -> Result;
}
extern "C" {
    pub fn bossGetTaskState(
        taskID: *const ::libc::c_char,
        inval: s8,
        status: *mut u8_,
        out1: *mut u32_,
        out2: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn bossGetTaskProperty0(taskID: *const ::libc::c_char, out: *mut u8_) -> Result;
}
extern "C" {
    pub fn bossSetupContextDefault(
        ctx: *mut bossContext,
        seconds_interval: u32_,
        url: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
pub const INPUT_YUV422_INDIV_8: Y2RU_InputFormat = 0;
pub const INPUT_YUV420_INDIV_8: Y2RU_InputFormat = 1;
pub const INPUT_YUV422_INDIV_16: Y2RU_InputFormat = 2;
pub const INPUT_YUV420_INDIV_16: Y2RU_InputFormat = 3;
pub const INPUT_YUV422_BATCH: Y2RU_InputFormat = 4;
pub type Y2RU_InputFormat = ::libc::c_uint;
pub const OUTPUT_RGB_32: Y2RU_OutputFormat = 0;
pub const OUTPUT_RGB_24: Y2RU_OutputFormat = 1;
pub const OUTPUT_RGB_16_555: Y2RU_OutputFormat = 2;
pub const OUTPUT_RGB_16_565: Y2RU_OutputFormat = 3;
pub type Y2RU_OutputFormat = ::libc::c_uint;
pub const ROTATION_NONE: Y2RU_Rotation = 0;
pub const ROTATION_CLOCKWISE_90: Y2RU_Rotation = 1;
pub const ROTATION_CLOCKWISE_180: Y2RU_Rotation = 2;
pub const ROTATION_CLOCKWISE_270: Y2RU_Rotation = 3;
pub type Y2RU_Rotation = ::libc::c_uint;
pub const BLOCK_LINE: Y2RU_BlockAlignment = 0;
pub const BLOCK_8_BY_8: Y2RU_BlockAlignment = 1;
pub type Y2RU_BlockAlignment = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_ColorCoefficients {
    pub rgb_Y: u16_,
    pub r_V: u16_,
    pub g_V: u16_,
    pub g_U: u16_,
    pub b_U: u16_,
    pub r_offset: u16_,
    pub g_offset: u16_,
    pub b_offset: u16_,
}
pub const COEFFICIENT_ITU_R_BT_601: Y2RU_StandardCoefficient = 0;
pub const COEFFICIENT_ITU_R_BT_709: Y2RU_StandardCoefficient = 1;
pub const COEFFICIENT_ITU_R_BT_601_SCALING: Y2RU_StandardCoefficient = 2;
pub const COEFFICIENT_ITU_R_BT_709_SCALING: Y2RU_StandardCoefficient = 3;
pub type Y2RU_StandardCoefficient = ::libc::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_ConversionParams {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub input_line_width: s16,
    pub input_lines: s16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub unused: u8_,
    pub alpha: u16_,
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        input_format: Y2RU_InputFormat,
        output_format: Y2RU_OutputFormat,
        rotation: Y2RU_Rotation,
        block_alignment: Y2RU_BlockAlignment,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let input_format: u32 = unsafe { ::core::mem::transmute(input_format) };
            input_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let output_format: u32 = unsafe { ::core::mem::transmute(output_format) };
            output_format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let block_alignment: u32 = unsafe { ::core::mem::transmute(block_alignment) };
            block_alignment as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        standard_coefficient: Y2RU_StandardCoefficient,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let standard_coefficient: u32 = unsafe { ::core::mem::transmute(standard_coefficient) };
            standard_coefficient as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_DitheringWeightParams {
    pub w0_xEven_yEven: u16_,
    pub w0_xOdd_yEven: u16_,
    pub w0_xEven_yOdd: u16_,
    pub w0_xOdd_yOdd: u16_,
    pub w1_xEven_yEven: u16_,
    pub w1_xOdd_yEven: u16_,
    pub w1_xEven_yOdd: u16_,
    pub w1_xOdd_yOdd: u16_,
    pub w2_xEven_yEven: u16_,
    pub w2_xOdd_yEven: u16_,
    pub w2_xEven_yOdd: u16_,
    pub w2_xOdd_yOdd: u16_,
    pub w3_xEven_yEven: u16_,
    pub w3_xOdd_yEven: u16_,
    pub w3_xEven_yOdd: u16_,
    pub w3_xOdd_yOdd: u16_,
}
extern "C" {
    pub fn y2rInit() -> Result;
}
extern "C" {
    pub fn y2rExit();
}
extern "C" {
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLineWidth(line_width: u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLines(num_lines: u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLines(num_lines: *mut u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient) -> Result;
}
extern "C" {
    pub fn Y2RU_GetStandardCoefficient(
        coefficients: *mut Y2RU_ColorCoefficients,
        standardCoeff: Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetAlpha(alpha: u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_GetAlpha(alpha: *mut u16_) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingY(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingU(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingYUYV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_SetReceiving(
        dst_buf: *mut ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetDitheringWeightParams(params: *const Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    pub fn Y2RU_GetDitheringWeightParams(params: *mut Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams) -> Result;
}
extern "C" {
    pub fn Y2RU_StartConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_StopConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_PingProcess(ping: *mut u8_) -> Result;
}
extern "C" {
    pub fn Y2RU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn Y2RU_DriverFinalize() -> Result;
}
pub const PORT_NONE: ::libc::c_uint = 0;
pub const PORT_CAM1: ::libc::c_uint = 1;
pub const PORT_CAM2: ::libc::c_uint = 2;
pub const PORT_BOTH: ::libc::c_uint = 3;
pub type _bindgen_ty_15 = ::libc::c_uint;
pub const SELECT_NONE: ::libc::c_uint = 0;
pub const SELECT_OUT1: ::libc::c_uint = 1;
pub const SELECT_IN1: ::libc::c_uint = 2;
pub const SELECT_OUT2: ::libc::c_uint = 4;
pub const SELECT_IN1_OUT1: ::libc::c_uint = 3;
pub const SELECT_OUT1_OUT2: ::libc::c_uint = 5;
pub const SELECT_IN1_OUT2: ::libc::c_uint = 6;
pub const SELECT_ALL: ::libc::c_uint = 7;
pub type _bindgen_ty_16 = ::libc::c_uint;
pub const CONTEXT_NONE: CAMU_Context = 0;
pub const CONTEXT_A: CAMU_Context = 1;
pub const CONTEXT_B: CAMU_Context = 2;
pub const CONTEXT_BOTH: CAMU_Context = 3;
pub type CAMU_Context = ::libc::c_uint;
pub const FLIP_NONE: CAMU_Flip = 0;
pub const FLIP_HORIZONTAL: CAMU_Flip = 1;
pub const FLIP_VERTICAL: CAMU_Flip = 2;
pub const FLIP_REVERSE: CAMU_Flip = 3;
pub type CAMU_Flip = ::libc::c_uint;
pub const SIZE_VGA: CAMU_Size = 0;
pub const SIZE_QVGA: CAMU_Size = 1;
pub const SIZE_QQVGA: CAMU_Size = 2;
pub const SIZE_CIF: CAMU_Size = 3;
pub const SIZE_QCIF: CAMU_Size = 4;
pub const SIZE_DS_LCD: CAMU_Size = 5;
pub const SIZE_DS_LCDx4: CAMU_Size = 6;
pub const SIZE_CTR_TOP_LCD: CAMU_Size = 7;
pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = 1;
pub type CAMU_Size = ::libc::c_uint;
pub const FRAME_RATE_15: CAMU_FrameRate = 0;
pub const FRAME_RATE_15_TO_5: CAMU_FrameRate = 1;
pub const FRAME_RATE_15_TO_2: CAMU_FrameRate = 2;
pub const FRAME_RATE_10: CAMU_FrameRate = 3;
pub const FRAME_RATE_8_5: CAMU_FrameRate = 4;
pub const FRAME_RATE_5: CAMU_FrameRate = 5;
pub const FRAME_RATE_20: CAMU_FrameRate = 6;
pub const FRAME_RATE_20_TO_5: CAMU_FrameRate = 7;
pub const FRAME_RATE_30: CAMU_FrameRate = 8;
pub const FRAME_RATE_30_TO_5: CAMU_FrameRate = 9;
pub const FRAME_RATE_15_TO_10: CAMU_FrameRate = 10;
pub const FRAME_RATE_20_TO_10: CAMU_FrameRate = 11;
pub const FRAME_RATE_30_TO_10: CAMU_FrameRate = 12;
pub type CAMU_FrameRate = ::libc::c_uint;
pub const WHITE_BALANCE_AUTO: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_3200K: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_4150K: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_5200K: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_6000K: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_7000K: CAMU_WhiteBalance = 5;
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance = 5;
pub type CAMU_WhiteBalance = ::libc::c_uint;
pub const PHOTO_MODE_NORMAL: CAMU_PhotoMode = 0;
pub const PHOTO_MODE_PORTRAIT: CAMU_PhotoMode = 1;
pub const PHOTO_MODE_LANDSCAPE: CAMU_PhotoMode = 2;
pub const PHOTO_MODE_NIGHTVIEW: CAMU_PhotoMode = 3;
pub const PHOTO_MODE_LETTER: CAMU_PhotoMode = 4;
pub type CAMU_PhotoMode = ::libc::c_uint;
pub const EFFECT_NONE: CAMU_Effect = 0;
pub const EFFECT_MONO: CAMU_Effect = 1;
pub const EFFECT_SEPIA: CAMU_Effect = 2;
pub const EFFECT_NEGATIVE: CAMU_Effect = 3;
pub const EFFECT_NEGAFILM: CAMU_Effect = 4;
pub const EFFECT_SEPIA01: CAMU_Effect = 5;
pub type CAMU_Effect = ::libc::c_uint;
pub const CONTRAST_PATTERN_01: CAMU_Contrast = 0;
pub const CONTRAST_PATTERN_02: CAMU_Contrast = 1;
pub const CONTRAST_PATTERN_03: CAMU_Contrast = 2;
pub const CONTRAST_PATTERN_04: CAMU_Contrast = 3;
pub const CONTRAST_PATTERN_05: CAMU_Contrast = 4;
pub const CONTRAST_PATTERN_06: CAMU_Contrast = 5;
pub const CONTRAST_PATTERN_07: CAMU_Contrast = 6;
pub const CONTRAST_PATTERN_08: CAMU_Contrast = 7;
pub const CONTRAST_PATTERN_09: CAMU_Contrast = 8;
pub const CONTRAST_PATTERN_10: CAMU_Contrast = 9;
pub const CONTRAST_PATTERN_11: CAMU_Contrast = 10;
pub const CONTRAST_LOW: CAMU_Contrast = 4;
pub const CONTRAST_NORMAL: CAMU_Contrast = 5;
pub const CONTRAST_HIGH: CAMU_Contrast = 6;
pub type CAMU_Contrast = ::libc::c_uint;
pub const LENS_CORRECTION_OFF: CAMU_LensCorrection = 0;
pub const LENS_CORRECTION_ON_70: CAMU_LensCorrection = 1;
pub const LENS_CORRECTION_ON_90: CAMU_LensCorrection = 2;
pub const LENS_CORRECTION_DARK: CAMU_LensCorrection = 0;
pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection = 1;
pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection = 2;
pub type CAMU_LensCorrection = ::libc::c_uint;
pub const OUTPUT_YUV_422: CAMU_OutputFormat = 0;
pub const OUTPUT_RGB_565: CAMU_OutputFormat = 1;
pub type CAMU_OutputFormat = ::libc::c_uint;
pub const SHUTTER_SOUND_TYPE_NORMAL: CAMU_ShutterSoundType = 0;
pub const SHUTTER_SOUND_TYPE_MOVIE: CAMU_ShutterSoundType = 1;
pub const SHUTTER_SOUND_TYPE_MOVIE_END: CAMU_ShutterSoundType = 2;
pub type CAMU_ShutterSoundType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMU_ImageQualityCalibrationData {
    pub aeBaseTarget: s16,
    pub kRL: s16,
    pub kGL: s16,
    pub kBL: s16,
    pub ccmPosition: s16,
    pub awbCcmL9Right: u16_,
    pub awbCcmL9Left: u16_,
    pub awbCcmL10Right: u16_,
    pub awbCcmL10Left: u16_,
    pub awbX0Right: u16_,
    pub awbX0Left: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMU_StereoCameraCalibrationData {
    pub isValidRotationXY: u8_,
    pub padding: [u8_; 3usize],
    pub scale: f32,
    pub rotationZ: f32,
    pub translationX: f32,
    pub translationY: f32,
    pub rotationX: f32,
    pub rotationY: f32,
    pub angleOfViewRight: f32,
    pub angleOfViewLeft: f32,
    pub distanceToChart: f32,
    pub distanceCameras: f32,
    pub imageWidth: s16,
    pub imageHeight: s16,
    pub reserved: [u8_; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMU_PackageParameterCameraSelect {
    pub camera: u8_,
    pub exposure: s8,
    pub whiteBalance: u8_,
    pub sharpness: s8,
    pub autoExposureOn: u8_,
    pub autoWhiteBalanceOn: u8_,
    pub frameRate: u8_,
    pub photoMode: u8_,
    pub contrast: u8_,
    pub lensCorrection: u8_,
    pub noiseFilterOn: u8_,
    pub padding: u8_,
    pub autoExposureWindowX: s16,
    pub autoExposureWindowY: s16,
    pub autoExposureWindowWidth: s16,
    pub autoExposureWindowHeight: s16,
    pub autoWhiteBalanceWindowX: s16,
    pub autoWhiteBalanceWindowY: s16,
    pub autoWhiteBalanceWindowWidth: s16,
    pub autoWhiteBalanceWindowHeight: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMU_PackageParameterContext {
    pub camera: u8_,
    pub context: u8_,
    pub flip: u8_,
    pub effect: u8_,
    pub size: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAMU_PackageParameterContextDetail {
    pub camera: u8_,
    pub context: u8_,
    pub flip: u8_,
    pub effect: u8_,
    pub width: s16,
    pub height: s16,
    pub cropX0: s16,
    pub cropY0: s16,
    pub cropX1: s16,
    pub cropY1: s16,
}
extern "C" {
    pub fn camInit() -> Result;
}
extern "C" {
    pub fn camExit();
}
extern "C" {
    pub fn CAMU_StartCapture(port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_StopCapture(port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_ClearBuffer(port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetReceiving(
        event: *mut Handle,
        dst: *mut ::libc::c_void,
        port: u32_,
        imageSize: u32_,
        transferUnit: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferLines(port: u32_, lines: s16, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferBytes(port: u32_, bytes: u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32_, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimming(port: u32_, trimming: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParams(
        port: u32_,
        xStart: s16,
        yStart: s16,
        xEnd: s16,
        yEnd: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_GetTrimmingParams(
        xStart: *mut s16,
        yStart: *mut s16,
        xEnd: *mut s16,
        yEnd: *mut s16,
        port: u32_,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParamsCenter(
        port: u32_,
        trimWidth: s16,
        trimHeight: s16,
        camWidth: s16,
        camHeight: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_Activate(select: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SwitchContext(select: u32_, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetExposure(select: u32_, exposure: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalance(select: u32_, whiteBalance: CAMU_WhiteBalance) -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(
        select: u32_,
        whiteBalance: CAMU_WhiteBalance,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetSharpness(select: u32_, sharpness: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposure(select: u32_, autoExposure: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalance(select: u32_, autoWhiteBalance: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_FlipImage(select: u32_, flip: CAMU_Flip, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetDetailSize(
        select: u32_,
        width: s16,
        height: s16,
        cropX0: s16,
        cropY0: s16,
        cropX1: s16,
        cropY1: s16,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetSize(select: u32_, size: CAMU_Size, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetFrameRate(select: u32_, frameRate: CAMU_FrameRate) -> Result;
}
extern "C" {
    pub fn CAMU_SetPhotoMode(select: u32_, photoMode: CAMU_PhotoMode) -> Result;
}
extern "C" {
    pub fn CAMU_SetEffect(select: u32_, effect: CAMU_Effect, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetContrast(select: u32_, contrast: CAMU_Contrast) -> Result;
}
extern "C" {
    pub fn CAMU_SetLensCorrection(select: u32_, lensCorrection: CAMU_LensCorrection) -> Result;
}
extern "C" {
    pub fn CAMU_SetOutputFormat(
        select: u32_,
        format: CAMU_OutputFormat,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposureWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalanceWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetNoiseFilter(select: u32_, noiseFilter: bool) -> Result;
}
extern "C" {
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32_, select2: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32_, past: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetStereoCameraCalibrationData(
        data: *mut CAMU_StereoCameraCalibrationData,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetStereoCameraCalibrationData(data: CAMU_StereoCameraCalibrationData) -> Result;
}
extern "C" {
    pub fn CAMU_WriteRegisterI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    pub fn CAMU_WriteMcuVariableI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    pub fn CAMU_SetImageQualityCalibrationData(data: CAMU_ImageQualityCalibrationData) -> Result;
}
extern "C" {
    pub fn CAMU_GetImageQualityCalibrationData(
        data: *mut CAMU_ImageQualityCalibrationData,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithoutContext(
        param: CAMU_PackageParameterCameraSelect,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContext(param: CAMU_PackageParameterContext) -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContextDetail(
        param: CAMU_PackageParameterContextDetail,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_GetSuitableY2rStandardCoefficient(
        coefficient: *mut Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
extern "C" {
    pub fn CAMU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn CAMU_DriverFinalize() -> Result;
}
extern "C" {
    pub fn CAMU_GetActivatedCamera(select: *mut u32_) -> Result;
}
extern "C" {
    pub fn CAMU_GetSleepCamera(select: *mut u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetSleepCamera(select: u32_) -> Result;
}
extern "C" {
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool) -> Result;
}
extern "C" {
    pub fn cfgnorInit(value: u8_) -> Result;
}
extern "C" {
    pub fn cfgnorExit();
}
extern "C" {
    pub fn cfgnorDumpFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn cfgnorWriteFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn CFGNOR_Initialize(value: u8_) -> Result;
}
extern "C" {
    pub fn CFGNOR_Shutdown() -> Result;
}
extern "C" {
    pub fn CFGNOR_ReadData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    pub fn CFGNOR_WriteData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
pub const CFG_REGION_JPN: CFG_Region = 0;
pub const CFG_REGION_USA: CFG_Region = 1;
pub const CFG_REGION_EUR: CFG_Region = 2;
pub const CFG_REGION_AUS: CFG_Region = 3;
pub const CFG_REGION_CHN: CFG_Region = 4;
pub const CFG_REGION_KOR: CFG_Region = 5;
pub const CFG_REGION_TWN: CFG_Region = 6;
pub type CFG_Region = ::libc::c_uint;
pub const CFG_LANGUAGE_JP: CFG_Language = 0;
pub const CFG_LANGUAGE_EN: CFG_Language = 1;
pub const CFG_LANGUAGE_FR: CFG_Language = 2;
pub const CFG_LANGUAGE_DE: CFG_Language = 3;
pub const CFG_LANGUAGE_IT: CFG_Language = 4;
pub const CFG_LANGUAGE_ES: CFG_Language = 5;
pub const CFG_LANGUAGE_ZH: CFG_Language = 6;
pub const CFG_LANGUAGE_KO: CFG_Language = 7;
pub const CFG_LANGUAGE_NL: CFG_Language = 8;
pub const CFG_LANGUAGE_PT: CFG_Language = 9;
pub const CFG_LANGUAGE_RU: CFG_Language = 10;
pub const CFG_LANGUAGE_TW: CFG_Language = 11;
pub type CFG_Language = ::libc::c_uint;
pub const CFG_MODEL_3DS: CFG_SystemModel = 0;
pub const CFG_MODEL_3DSXL: CFG_SystemModel = 1;
pub const CFG_MODEL_N3DS: CFG_SystemModel = 2;
pub const CFG_MODEL_2DS: CFG_SystemModel = 3;
pub const CFG_MODEL_N3DSXL: CFG_SystemModel = 4;
pub const CFG_MODEL_N2DSXL: CFG_SystemModel = 5;
pub type CFG_SystemModel = ::libc::c_uint;
extern "C" {
    pub fn cfguInit() -> Result;
}
extern "C" {
    pub fn cfguExit();
}
extern "C" {
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32_, hash: *mut u64_) -> Result;
}
extern "C" {
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemModel(model: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeString(code: u16_, string: *mut u16_) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeID(string: u16_, code: *mut u16_) -> Result;
}
extern "C" {
    pub fn CFGU_IsNFCSupported(isSupported: *mut bool) -> Result;
}
extern "C" {
    pub fn CFGU_GetConfigInfoBlk2(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk4(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk8(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk4(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk8(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    pub fn CFG_UpdateConfigSavegame() -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemLanguage(language: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGI_RestoreLocalFriendCodeSeed() -> Result;
}
extern "C" {
    pub fn CFGI_RestoreSecureInfo() -> Result;
}
extern "C" {
    pub fn CFGI_DeleteConfigSavefile() -> Result;
}
extern "C" {
    pub fn CFGI_FormatConfig() -> Result;
}
extern "C" {
    pub fn CFGI_ClearParentalControls() -> Result;
}
extern "C" {
    pub fn CFGI_VerifySigLocalFriendCodeSeed() -> Result;
}
extern "C" {
    pub fn CFGI_VerifySigSecureInfo() -> Result;
}
extern "C" {
    pub fn CFGI_SecureInfoGetSerialNumber(serial: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGI_GetLocalFriendCodeSeedData(data: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGI_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    pub fn CFGI_GetSecureInfoData(data: *mut u8_) -> Result;
}
extern "C" {
    pub fn CFGI_GetSecureInfoSignature(data: *mut u8_) -> Result;
}
pub const CSND_ENCODING_PCM8: ::libc::c_uint = 0;
pub const CSND_ENCODING_PCM16: ::libc::c_uint = 1;
pub const CSND_ENCODING_ADPCM: ::libc::c_uint = 2;
pub const CSND_ENCODING_PSG: ::libc::c_uint = 3;
pub type _bindgen_ty_17 = ::libc::c_uint;
pub const CSND_LOOPMODE_MANUAL: ::libc::c_uint = 0;
pub const CSND_LOOPMODE_NORMAL: ::libc::c_uint = 1;
pub const CSND_LOOPMODE_ONESHOT: ::libc::c_uint = 2;
pub const CSND_LOOPMODE_NORELOAD: ::libc::c_uint = 3;
pub type _bindgen_ty_18 = ::libc::c_uint;
pub const SOUND_LINEAR_INTERP: ::libc::c_uint = 64;
pub const SOUND_REPEAT: ::libc::c_uint = 1024;
pub const SOUND_ONE_SHOT: ::libc::c_uint = 2048;
pub const SOUND_FORMAT_8BIT: ::libc::c_uint = 0;
pub const SOUND_FORMAT_16BIT: ::libc::c_uint = 4096;
pub const SOUND_FORMAT_ADPCM: ::libc::c_uint = 8192;
pub const SOUND_FORMAT_PSG: ::libc::c_uint = 12288;
pub const SOUND_ENABLE: ::libc::c_uint = 16384;
pub type _bindgen_ty_19 = ::libc::c_uint;
pub const CAPTURE_REPEAT: ::libc::c_uint = 0;
pub const CAPTURE_ONE_SHOT: ::libc::c_uint = 1;
pub const CAPTURE_FORMAT_16BIT: ::libc::c_uint = 0;
pub const CAPTURE_FORMAT_8BIT: ::libc::c_uint = 2;
pub const CAPTURE_ENABLE: ::libc::c_uint = 32768;
pub type _bindgen_ty_20 = ::libc::c_uint;
pub const DutyCycle_0: CSND_DutyCycle = 7;
pub const DutyCycle_12: CSND_DutyCycle = 0;
pub const DutyCycle_25: CSND_DutyCycle = 1;
pub const DutyCycle_37: CSND_DutyCycle = 2;
pub const DutyCycle_50: CSND_DutyCycle = 3;
pub const DutyCycle_62: CSND_DutyCycle = 4;
pub const DutyCycle_75: CSND_DutyCycle = 5;
pub const DutyCycle_87: CSND_DutyCycle = 6;
pub type CSND_DutyCycle = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_ChnInfo {
    pub value: [u32_; 3usize],
    pub __bindgen_anon_1: CSND_ChnInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    pub active: u8_,
    pub _pad1: u8_,
    pub _pad2: u16_,
    pub adpcmSample: s16,
    pub adpcmIndex: u8_,
    pub _pad3: u8_,
    pub unknownZero: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_CapInfo {
    pub value: [u32_; 2usize],
    pub __bindgen_anon_1: CSND_CapInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    pub active: u8_,
    pub _pad1: u8_,
    pub _pad2: u16_,
    pub unknownZero: u32_,
}
extern "C" {
    pub static mut csndSharedMem: *mut vu32;
}
extern "C" {
    pub static mut csndSharedMemSize: u32_;
}
extern "C" {
    pub static mut csndChannels: u32_;
}
extern "C" {
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32_) -> Result;
}
extern "C" {
    pub fn CSND_ReleaseCapUnit(capUnit: u32_) -> Result;
}
extern "C" {
    pub fn CSND_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn CSND_StoreDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn CSND_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn CSND_Reset() -> Result;
}
extern "C" {
    pub fn csndInit() -> Result;
}
extern "C" {
    pub fn csndExit();
}
extern "C" {
    pub fn csndAddCmd(cmdid: ::libc::c_int) -> *mut u32_;
}
extern "C" {
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut u8_);
}
extern "C" {
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_SetPlayStateR(channel: u32_, value: u32_);
}
extern "C" {
    pub fn CSND_SetPlayState(channel: u32_, value: u32_);
}
extern "C" {
    pub fn CSND_SetEncoding(channel: u32_, value: u32_);
}
extern "C" {
    pub fn CSND_SetBlock(channel: u32_, block: ::libc::c_int, physaddr: u32_, size: u32_);
}
extern "C" {
    pub fn CSND_SetLooping(channel: u32_, value: u32_);
}
extern "C" {
    pub fn CSND_SetBit7(channel: u32_, set: bool);
}
extern "C" {
    pub fn CSND_SetInterp(channel: u32_, interp: bool);
}
extern "C" {
    pub fn CSND_SetDuty(channel: u32_, duty: CSND_DutyCycle);
}
extern "C" {
    pub fn CSND_SetTimer(channel: u32_, timer: u32_);
}
extern "C" {
    pub fn CSND_SetVol(channel: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    pub fn CSND_SetAdpcmState(
        channel: u32_,
        block: ::libc::c_int,
        sample: ::libc::c_int,
        index: ::libc::c_int,
    );
}
extern "C" {
    pub fn CSND_SetAdpcmReload(channel: u32_, reload: bool);
}
extern "C" {
    pub fn CSND_SetChnRegs(
        flags: u32_,
        physaddr0: u32_,
        physaddr1: u32_,
        totalbytesize: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
    );
}
extern "C" {
    pub fn CSND_SetChnRegsPSG(
        flags: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
        duty: CSND_DutyCycle,
    );
}
extern "C" {
    pub fn CSND_SetChnRegsNoise(flags: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    pub fn CSND_CapEnable(capUnit: u32_, enable: bool);
}
extern "C" {
    pub fn CSND_CapSetRepeat(capUnit: u32_, repeat: bool);
}
extern "C" {
    pub fn CSND_CapSetFormat(capUnit: u32_, eightbit: bool);
}
extern "C" {
    pub fn CSND_CapSetBit2(capUnit: u32_, set: bool);
}
extern "C" {
    pub fn CSND_CapSetTimer(capUnit: u32_, timer: u32_);
}
extern "C" {
    pub fn CSND_CapSetBuffer(capUnit: u32_, addr: u32_, size: u32_);
}
extern "C" {
    pub fn CSND_SetCapRegs(capUnit: u32_, flags: u32_, addr: u32_, size: u32_);
}
extern "C" {
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
extern "C" {
    pub fn csndPlaySound(
        chn: ::libc::c_int,
        flags: u32_,
        sampleRate: u32_,
        vol: f32,
        pan: f32,
        data0: *mut ::libc::c_void,
        data1: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn csndGetDspFlags(outSemFlags: *mut u32_, outIrqFlags: *mut u32_);
}
extern "C" {
    pub fn csndGetChnInfo(channel: u32_) -> *mut CSND_ChnInfo;
}
extern "C" {
    pub fn csndGetCapInfo(capUnit: u32_) -> *mut CSND_CapInfo;
}
extern "C" {
    pub fn csndGetState(channel: u32_, out: *mut CSND_ChnInfo) -> Result;
}
extern "C" {
    pub fn csndIsPlaying(channel: u32_, status: *mut u8_) -> Result;
}
pub const DSP_INTERRUPT_PIPE: DSP_InterruptType = 2;
pub type DSP_InterruptType = ::libc::c_uint;
pub const DSPHOOK_ONSLEEP: DSP_HookType = 0;
pub const DSPHOOK_ONWAKEUP: DSP_HookType = 1;
pub const DSPHOOK_ONCANCEL: DSP_HookType = 2;
pub type DSP_HookType = ::libc::c_uint;
pub type dspHookFn = ::core::option::Option<unsafe extern "C" fn(hook: DSP_HookType)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_dspHookCookie {
    pub next: *mut tag_dspHookCookie,
    pub callback: dspHookFn,
}
pub type dspHookCookie = tag_dspHookCookie;
extern "C" {
    pub fn dspInit() -> Result;
}
extern "C" {
    pub fn dspExit();
}
extern "C" {
    pub fn dspIsComponentLoaded() -> bool;
}
extern "C" {
    pub fn dspHook(cookie: *mut dspHookCookie, callback: dspHookFn);
}
extern "C" {
    pub fn dspUnhook(cookie: *mut dspHookCookie);
}
extern "C" {
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_FlushDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn DSP_InvalidateDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphore(value: u16_) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphoreMask(mask: u16_) -> Result;
}
extern "C" {
    pub fn DSP_LoadComponent(
        component: *const ::libc::c_void,
        size: u32_,
        prog_mask: u16_,
        data_mask: u16_,
        is_loaded: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn DSP_UnloadComponent() -> Result;
}
extern "C" {
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32_, channel: u32_) -> Result;
}
extern "C" {
    pub fn DSP_ReadPipeIfPossible(
        channel: u32_,
        peer: u32_,
        buffer: *mut ::libc::c_void,
        length: u16_,
        length_read: *mut u16_,
    ) -> Result;
}
extern "C" {
    pub fn DSP_WriteProcessPipe(
        channel: u32_,
        buffer: *const ::libc::c_void,
        length: u32_,
    ) -> Result;
}
extern "C" {
    pub fn DSP_ConvertProcessAddressFromDspDram(
        dsp_address: u32_,
        arm_address: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn DSP_RecvData(regNo: u16_, value: *mut u16_) -> Result;
}
extern "C" {
    pub fn DSP_RecvDataIsReady(regNo: u16_, is_ready: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_SendData(regNo: u16_, value: u16_) -> Result;
}
extern "C" {
    pub fn DSP_SendDataIsEmpty(regNo: u16_, is_empty: *mut bool) -> Result;
}
pub type FSPXI_Archive = u64_;
pub type FSPXI_File = u64_;
pub type FSPXI_Directory = u64_;
extern "C" {
    pub fn FSPXI_OpenFile(
        serviceHandle: Handle,
        out: *mut FSPXI_File,
        archive: FSPXI_Archive,
        path: FS_Path,
        flags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_DeleteFile(serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path)
        -> Result;
}
extern "C" {
    pub fn FSPXI_RenameFile(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_DeleteDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CreateFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CreateDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_RenameDirectory(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_OpenDirectory(
        serviceHandle: Handle,
        out: *mut FSPXI_Directory,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ReadFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CalculateFileHashSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_WriteFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CalcSavegameMAC(
        serviceHandle: Handle,
        file: FSPXI_File,
        inBuffer: *const ::libc::c_void,
        inSize: u32_,
        outBuffer: *mut ::libc::c_void,
        outSize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetFileSize(serviceHandle: Handle, file: FSPXI_File, size: *mut u64_) -> Result;
}
extern "C" {
    pub fn FSPXI_SetFileSize(serviceHandle: Handle, file: FSPXI_File, size: u64_) -> Result;
}
extern "C" {
    pub fn FSPXI_CloseFile(serviceHandle: Handle, file: FSPXI_File) -> Result;
}
extern "C" {
    pub fn FSPXI_ReadDirectory(
        serviceHandle: Handle,
        directory: FSPXI_Directory,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CloseDirectory(serviceHandle: Handle, directory: FSPXI_Directory) -> Result;
}
extern "C" {
    pub fn FSPXI_OpenArchive(
        serviceHandle: Handle,
        archive: *mut FSPXI_Archive,
        archiveID: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_HasFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_HasDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CommitSaveData(serviceHandle: Handle, archive: FSPXI_Archive, id: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_CloseArchive(serviceHandle: Handle, archive: FSPXI_Archive) -> Result;
}
extern "C" {
    pub fn FSPXI_Unknown0x17(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetCardType(serviceHandle: Handle, out: *mut FS_CardType) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetNandArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcFatFsError(serviceHandle: Handle, out: *mut u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_IsSdmcDetected(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_IsSdmcWritable(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_GetNandCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    pub fn FSPXI_GetNandSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_GetNandLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_ClearSdmcLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_ClearNandLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_CardSlotIsInserted(serviceHandle: Handle, inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_CardSlotPowerOn(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_CardSlotPowerOff(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_CardSlotGetCardIFPowerStatus(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectCommand(serviceHandle: Handle, commandId: u8_) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectCommandWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectRead(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectReadWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectWrite(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectWriteWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectRead_4xIO(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectCpuWriteWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_CardNorDirectSectorEraseWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetProductInfo(
        serviceHandle: Handle,
        info: *mut FS_ProductInfo,
        archive: FSPXI_Archive,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_SetCardSpiBaudrate(serviceHandle: Handle, baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    pub fn FSPXI_SetCardSpiBusMode(serviceHandle: Handle, busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    pub fn FSPXI_SendInitializeInfoTo9(serviceHandle: Handle, unk: u8_) -> Result;
}
extern "C" {
    pub fn FSPXI_CreateExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSPXI_DeleteExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSPXI_EnumerateExtSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSpecialContentIndex(
        serviceHandle: Handle,
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetLegacyRomHeader(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetLegacyBannerData(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
        unk: u8_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_FormatCardNorDevice(serviceHandle: Handle, unk: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_DeleteSdmcRoot(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_DeleteAllExtSaveDataOnNand(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_InitializeCtrFilesystem(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_CreateSeed(serviceHandle: Handle) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSdmcCtrRootPath(serviceHandle: Handle, out: *mut u16_, length: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_GetArchiveResource(
        serviceHandle: Handle,
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ExportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ImportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *const FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetLegacySubBannerData(
        serviceHandle: Handle,
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GenerateRandomBytes(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetFileLastModified(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut u64_,
        path: *const u16_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ReadSpecialFile(
        serviceHandle: Handle,
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_GetSpecialFileSize(serviceHandle: Handle, fileSize: *mut u64_) -> Result;
}
extern "C" {
    pub fn FSPXI_StartDeviceMoveAsSource(
        serviceHandle: Handle,
        context: *mut FS_DeviceMoveContext,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_StartDeviceMoveAsDestination(
        serviceHandle: Handle,
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ReadFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        readBuffer: *mut ::libc::c_void,
        readBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_WriteFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        writeBuffer: *const ::libc::c_void,
        writeBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk1: u32_,
        unk2: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_SetCtrCardLatencyParameter(serviceHandle: Handle, latency: u64_) -> Result;
}
extern "C" {
    pub fn FSPXI_SetPriority(serviceHandle: Handle, priority: u32_) -> Result;
}
extern "C" {
    pub fn FSPXI_SwitchCleanupInvalidSaveData(serviceHandle: Handle, enable: bool) -> Result;
}
extern "C" {
    pub fn FSPXI_EnumerateSystemSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_ReadNandReport(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FSPXI_Unknown0x56(
        serviceHandle: Handle,
        out: *mut u32_,
        archive: FS_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    pub fn fsRegInit() -> Result;
}
extern "C" {
    pub fn fsRegExit();
}
extern "C" {
    pub fn fsRegGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn FSREG_Register(
        pid: u32_,
        programHandle: u64_,
        programInfo: *const FS_ProgramInfo,
        storageInfo: *const ExHeader_Arm11StorageInfo,
    ) -> Result;
}
extern "C" {
    pub fn FSREG_Unregister(pid: u32_) -> Result;
}
extern "C" {
    pub fn FSREG_GetProgramInfo(
        exheaderInfos: *mut ExHeader_Info,
        maxNumEntries: u32_,
        programHandle: u64_,
    ) -> Result;
}
extern "C" {
    pub fn FSREG_LoadProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn FSREG_UnloadProgram(programHandle: u64_) -> Result;
}
extern "C" {
    pub fn FSREG_CheckHostLoadId(programHandle: u64_) -> Result;
}
#[repr(C)]
#[repr(align(1))]
pub struct MiiData {
    pub _bindgen_opaque_blob: [u8; 92usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_1 {
    #[inline]
    pub fn allow_copying(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_copying(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_private_name(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_private_name(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn region_lock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_lock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn char_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_char_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allow_copying: bool,
        is_private_name: bool,
        region_lock: u8_,
        char_set: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allow_copying: u8 = unsafe { ::core::mem::transmute(allow_copying) };
            allow_copying as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_private_name: u8 = unsafe { ::core::mem::transmute(is_private_name) };
            is_private_name as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let region_lock: u8 = unsafe { ::core::mem::transmute(region_lock) };
            region_lock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let char_set: u8 = unsafe { ::core::mem::transmute(char_set) };
            char_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_2 {
    #[inline]
    pub fn page_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_page_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slot_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_slot_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(page_index: u8_, slot_index: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let page_index: u8 = unsafe { ::core::mem::transmute(page_index) };
            page_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let slot_index: u8 = unsafe { ::core::mem::transmute(slot_index) };
            slot_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_3 {
    #[inline]
    pub fn unknown0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unknown0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn origin_console(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_origin_console(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unknown0: u8_,
        origin_console: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let unknown0: u8 = unsafe { ::core::mem::transmute(unknown0) };
            unknown0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let origin_console: u8 = unsafe { ::core::mem::transmute(origin_console) };
            origin_console as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_4 {
    #[inline]
    pub fn sex(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sex(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_month(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_bday_month(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_day(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_bday_day(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn shirt_color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_shirt_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn favorite(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_favorite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sex: bool,
        bday_month: u16_,
        bday_day: u16_,
        shirt_color: u16_,
        favorite: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sex: u8 = unsafe { ::core::mem::transmute(sex) };
            sex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let bday_month: u16 = unsafe { ::core::mem::transmute(bday_month) };
            bday_month as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let bday_day: u16 = unsafe { ::core::mem::transmute(bday_day) };
            bday_day as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let shirt_color: u16 = unsafe { ::core::mem::transmute(shirt_color) };
            shirt_color as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let favorite: u8 = unsafe { ::core::mem::transmute(favorite) };
            favorite as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_5 {
    #[inline]
    pub fn disable_sharing(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable_sharing(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shape(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skinColor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_skinColor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_sharing: bool,
        shape: u8_,
        skinColor: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_sharing: u8 = unsafe { ::core::mem::transmute(disable_sharing) };
            disable_sharing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let shape: u8 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let skinColor: u8 = unsafe { ::core::mem::transmute(skinColor) };
            skinColor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_6 {
    #[inline]
    pub fn wrinkles(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_wrinkles(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn makeup(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_makeup(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wrinkles: u8_, makeup: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let wrinkles: u8 = unsafe { ::core::mem::transmute(wrinkles) };
            wrinkles as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let makeup: u8 = unsafe { ::core::mem::transmute(makeup) };
            makeup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_7 {
    #[inline]
    pub fn color(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(color: u8_, flip: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let color: u8 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flip: u8 = unsafe { ::core::mem::transmute(flip) };
            flip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_8 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_9 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        pad: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pad: u32 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_10 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_10 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        scale: u16_,
        yposition: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_11 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_11 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_12 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_12 {
    #[inline]
    pub fn mouth_yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mouth_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustach_style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_mustach_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mouth_yposition: u16_,
        mustach_style: u16_,
        pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mouth_yposition: u16 = unsafe { ::core::mem::transmute(mouth_yposition) };
            mouth_yposition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mustach_style: u16 = unsafe { ::core::mem::transmute(mustach_style) };
            mustach_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let pad: u16 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_13 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_13 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_14 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_14 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct MiiData__bindgen_ty_15 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_15 {
    #[inline]
    pub fn enable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xpos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_xpos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: bool,
        scale: u16_,
        xpos: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let xpos: u16 = unsafe { ::core::mem::transmute(xpos) };
            xpos as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FriendKey {
    pub principalId: u32_,
    pub padding: u32_,
    pub localFriendCode: u64_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TitleData {
    pub tid: u64_,
    pub version: u32_,
    pub unk: u32_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FriendProfile {
    pub region: u8_,
    pub country: u8_,
    pub area: u8_,
    pub language: u8_,
    pub platform: u8_,
    pub padding: u32_,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GameDescription {
    pub data: TitleData,
    pub desc: [u16_; 128usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationEvent {
    pub type_: u8_,
    pub padding3: [u8_; 3usize],
    pub padding: u32_,
    pub key: FriendKey,
}
pub const USER_WENT_ONLINE: NotificationTypes = 1;
pub const USER_WENT_OFFLINE: NotificationTypes = 2;
pub const FRIEND_WENT_ONLINE: NotificationTypes = 3;
pub const FRIEND_UPDATED_PRESENCE: NotificationTypes = 4;
pub const FRIEND_UPDATED_MII: NotificationTypes = 5;
pub const FRIEND_UPDATED_PROFILE: NotificationTypes = 6;
pub const FRIEND_WENT_OFFLINE: NotificationTypes = 7;
pub const FRIEND_REGISTERED_USER: NotificationTypes = 8;
pub const FRIEND_SENT_INVITATION: NotificationTypes = 9;
pub type NotificationTypes = ::libc::c_uint;
extern "C" {
    pub fn frdInit() -> Result;
}
extern "C" {
    pub fn frdExit();
}
extern "C" {
    pub fn frdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn FRDU_HasLoggedIn(state: *mut bool) -> Result;
}
extern "C" {
    pub fn FRDU_IsOnline(state: *mut bool) -> Result;
}
extern "C" {
    pub fn FRD_Logout() -> Result;
}
extern "C" {
    pub fn FRD_Login(event: Handle) -> Result;
}
extern "C" {
    pub fn FRD_GetMyFriendKey(key: *mut FriendKey) -> Result;
}
extern "C" {
    pub fn FRD_GetMyPreference(
        isPublicMode: *mut bool,
        isShowGameName: *mut bool,
        isShowPlayedGame: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn FRD_GetMyProfile(profile: *mut FriendProfile) -> Result;
}
extern "C" {
    pub fn FRD_GetMyScreenName(name: *mut ::libc::c_char, max_size: size_t) -> Result;
}
extern "C" {
    pub fn FRD_GetMyMii(mii: *mut MiiData) -> Result;
}
extern "C" {
    pub fn FRD_GetMyPlayingGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    pub fn FRD_GetMyFavoriteGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    pub fn FRD_GetMyComment(comment: *mut ::libc::c_char, max_size: size_t) -> Result;
}
extern "C" {
    pub fn FRD_GetFriendKeyList(
        friendKeyList: *mut FriendKey,
        num: *mut u32_,
        offset: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FRD_GetFriendMii(
        miiDataList: *mut MiiData,
        friendKeyList: *const FriendKey,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn FRD_GetFriendProfile(
        profile: *mut FriendProfile,
        friendKeyList: *const FriendKey,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn FRD_GetFriendPlayingGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn FRD_GetFriendFavouriteGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
extern "C" {
    pub fn FRD_IsInFriendList(friendKeyList: *mut FriendKey, isFromList: *mut bool) -> Result;
}
extern "C" {
    pub fn FRD_UpdateGameModeDescription(desc: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn FRD_AttachToEventNotification(event: Handle) -> Result;
}
extern "C" {
    pub fn FRD_GetEventNotification(
        event: *mut NotificationEvent,
        count: u32_,
        recievedNotifCount: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn FRD_PrincipalIdToFriendCode(principalId: u32_, friendCode: *mut u64_) -> Result;
}
extern "C" {
    pub fn FRD_FriendCodeToPrincipalId(friendCode: u64_, principalId: *mut u32_) -> Result;
}
extern "C" {
    pub fn FRD_IsValidFriendCode(friendCode: u64_, isValid: *mut bool) -> Result;
}
extern "C" {
    pub fn FRD_SetClientSdkVersion(sdkVer: u32_) -> Result;
}
extern "C" {
    pub fn FRD_AddFriendOnline(event: Handle, principalId: u32_) -> Result;
}
extern "C" {
    pub fn FRD_RemoveFriend(principalId: u32_, localFriendCode: u64_) -> Result;
}
pub const GSPLCD_SCREEN_TOP: ::libc::c_uint = 1;
pub const GSPLCD_SCREEN_BOTTOM: ::libc::c_uint = 2;
pub const GSPLCD_SCREEN_BOTH: ::libc::c_uint = 3;
pub type _bindgen_ty_21 = ::libc::c_uint;
extern "C" {
    pub fn gspLcdInit() -> Result;
}
extern "C" {
    pub fn gspLcdExit();
}
extern "C" {
    pub fn gspLcdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn GSPLCD_PowerOnAllBacklights() -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOffAllBacklights() -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOnBacklight(screen: u32_) -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOffBacklight(screen: u32_) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetLedForceOff(disable: bool) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetVendors(vendors: *mut u8_) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetBrightness(screen: u32_, brightness: *mut u32_) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetBrightness(screen: u32_, brightness: u32_) -> Result;
}
extern "C" {
    pub fn GSPLCD_SetBrightnessRaw(screen: u32_, brightness: u32_) -> Result;
}
pub const KEY_A: ::libc::c_uint = 1;
pub const KEY_B: ::libc::c_uint = 2;
pub const KEY_SELECT: ::libc::c_uint = 4;
pub const KEY_START: ::libc::c_uint = 8;
pub const KEY_DRIGHT: ::libc::c_uint = 16;
pub const KEY_DLEFT: ::libc::c_uint = 32;
pub const KEY_DUP: ::libc::c_uint = 64;
pub const KEY_DDOWN: ::libc::c_uint = 128;
pub const KEY_R: ::libc::c_uint = 256;
pub const KEY_L: ::libc::c_uint = 512;
pub const KEY_X: ::libc::c_uint = 1024;
pub const KEY_Y: ::libc::c_uint = 2048;
pub const KEY_ZL: ::libc::c_uint = 16384;
pub const KEY_ZR: ::libc::c_uint = 32768;
pub const KEY_TOUCH: ::libc::c_uint = 1048576;
pub const KEY_CSTICK_RIGHT: ::libc::c_uint = 16777216;
pub const KEY_CSTICK_LEFT: ::libc::c_uint = 33554432;
pub const KEY_CSTICK_UP: ::libc::c_uint = 67108864;
pub const KEY_CSTICK_DOWN: ::libc::c_uint = 134217728;
pub const KEY_CPAD_RIGHT: ::libc::c_uint = 268435456;
pub const KEY_CPAD_LEFT: ::libc::c_uint = 536870912;
pub const KEY_CPAD_UP: ::libc::c_uint = 1073741824;
pub const KEY_CPAD_DOWN: ::libc::c_uint = 2147483648;
pub const KEY_UP: ::libc::c_uint = 1073741888;
pub const KEY_DOWN: ::libc::c_uint = 2147483776;
pub const KEY_LEFT: ::libc::c_uint = 536870944;
pub const KEY_RIGHT: ::libc::c_uint = 268435472;
pub type _bindgen_ty_22 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct touchPosition {
    pub px: u16_,
    pub py: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct circlePosition {
    pub dx: s16,
    pub dy: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accelVector {
    pub x: s16,
    pub y: s16,
    pub z: s16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct angularRate {
    pub x: s16,
    pub z: s16,
    pub y: s16,
}
pub const HIDEVENT_PAD0: HID_Event = 0;
pub const HIDEVENT_PAD1: HID_Event = 1;
pub const HIDEVENT_Accel: HID_Event = 2;
pub const HIDEVENT_Gyro: HID_Event = 3;
pub const HIDEVENT_DebugPad: HID_Event = 4;
pub const HIDEVENT_MAX: HID_Event = 5;
pub type HID_Event = ::libc::c_uint;
extern "C" {
    pub static mut hidMemHandle: Handle;
}
extern "C" {
    pub static mut hidSharedMem: *mut vu32;
}
extern "C" {
    pub fn hidInit() -> Result;
}
extern "C" {
    pub fn hidExit();
}
extern "C" {
    pub fn hidSetRepeatParameters(delay: u32_, interval: u32_);
}
extern "C" {
    pub fn hidScanInput();
}
extern "C" {
    pub fn hidKeysHeld() -> u32_;
}
extern "C" {
    pub fn hidKeysDown() -> u32_;
}
extern "C" {
    pub fn hidKeysDownRepeat() -> u32_;
}
extern "C" {
    pub fn hidKeysUp() -> u32_;
}
extern "C" {
    pub fn hidTouchRead(pos: *mut touchPosition);
}
extern "C" {
    pub fn hidCircleRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn hidAccelRead(vector: *mut accelVector);
}
extern "C" {
    pub fn hidGyroRead(rate: *mut angularRate);
}
extern "C" {
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
extern "C" {
    pub fn hidWaitForAnyEvent(nextEvents: bool, cancelEvent: Handle, timeout: s64) -> Result;
}
extern "C" {
    pub fn HIDUSER_GetHandles(
        outMemHandle: *mut Handle,
        eventpad0: *mut Handle,
        eventpad1: *mut Handle,
        eventaccel: *mut Handle,
        eventgyro: *mut Handle,
        eventdebugpad: *mut Handle,
    ) -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
extern "C" {
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8_) -> Result;
}
extern "C" {
    pub static mut irrstMemHandle: Handle;
}
extern "C" {
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    pub static mut irrstEvent: Handle;
}
extern "C" {
    pub fn irrstInit() -> Result;
}
extern "C" {
    pub fn irrstExit();
}
extern "C" {
    pub fn irrstScanInput();
}
extern "C" {
    pub fn irrstKeysHeld() -> u32_;
}
extern "C" {
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn irrstWaitForEvent(nextEvent: bool);
}
extern "C" {
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle, outEventHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn IRRST_Initialize(unk1: u32_, unk2: u8_) -> Result;
}
extern "C" {
    pub fn IRRST_Shutdown() -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sslcContext {
    pub servhandle: Handle,
    pub sslchandle: u32_,
    pub sharedmem_handle: Handle,
}
pub const SSLC_DefaultRootCert_Nintendo_CA: SSLC_DefaultRootCert = 1;
pub const SSLC_DefaultRootCert_Nintendo_CA_G2: SSLC_DefaultRootCert = 2;
pub const SSLC_DefaultRootCert_Nintendo_CA_G3: SSLC_DefaultRootCert = 3;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA: SSLC_DefaultRootCert = 4;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G2: SSLC_DefaultRootCert = 5;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G3: SSLC_DefaultRootCert = 6;
pub const SSLC_DefaultRootCert_CyberTrust: SSLC_DefaultRootCert = 7;
pub const SSLC_DefaultRootCert_AddTrust_External_CA: SSLC_DefaultRootCert = 8;
pub const SSLC_DefaultRootCert_COMODO: SSLC_DefaultRootCert = 9;
pub const SSLC_DefaultRootCert_USERTrust: SSLC_DefaultRootCert = 10;
pub const SSLC_DefaultRootCert_DigiCert_EV: SSLC_DefaultRootCert = 11;
pub type SSLC_DefaultRootCert = ::libc::c_uint;
pub const SSLC_DefaultClientCert_ClCertA: SSLC_DefaultClientCert = 64;
pub type SSLC_DefaultClientCert = ::libc::c_uint;
pub const SSLCOPT_Default: ::libc::c_uint = 0;
pub const SSLCOPT_DisableVerify: ::libc::c_uint = 512;
pub const SSLCOPT_TLSv10: ::libc::c_uint = 2048;
pub type _bindgen_ty_23 = ::libc::c_uint;
extern "C" {
    pub fn sslcInit(session_handle: Handle) -> Result;
}
extern "C" {
    pub fn sslcExit();
}
extern "C" {
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    pub fn sslcAddTrustedRootCA(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddCert(
        CertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddDefaultCert(
        CertChain_contexthandle: u32_,
        certID: u8_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslc8CertChainRemoveCert(
        CertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        key: *const u8_,
        keysize: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    pub fn sslcSeedRNG() -> Result;
}
extern "C" {
    pub fn sslcGenerateRandomData(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    pub fn sslcCreateContext(
        context: *mut sslcContext,
        sockfd: ::libc::c_int,
        input_opt: u32_,
        hostname: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
extern "C" {
    pub fn sslcStartConnection(
        context: *mut sslcContext,
        internal_retval: *mut ::libc::c_int,
        out: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcRead(
        context: *mut sslcContext,
        buf: *mut ::libc::c_void,
        len: size_t,
        peek: bool,
    ) -> Result;
}
extern "C" {
    pub fn sslcWrite(context: *mut sslcContext, buf: *const ::libc::c_void, len: size_t) -> Result;
}
extern "C" {
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32_) -> Result;
}
extern "C" {
    pub fn sslcContextGetProtocolCipher(
        context: *mut sslcContext,
        outprotocols: *mut ::libc::c_char,
        outprotocols_maxsize: u32_,
        outcipher: *mut ::libc::c_char,
        outcipher_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32_) -> Result;
}
extern "C" {
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8_, size: u32_)
        -> Result;
}
extern "C" {
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8_, size: u32_) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct httpcContext {
    pub servhandle: Handle,
    pub httphandle: u32_,
}
pub const HTTPC_METHOD_GET: HTTPC_RequestMethod = 1;
pub const HTTPC_METHOD_POST: HTTPC_RequestMethod = 2;
pub const HTTPC_METHOD_HEAD: HTTPC_RequestMethod = 3;
pub const HTTPC_METHOD_PUT: HTTPC_RequestMethod = 4;
pub const HTTPC_METHOD_DELETE: HTTPC_RequestMethod = 5;
pub type HTTPC_RequestMethod = ::libc::c_uint;
pub const HTTPC_STATUS_REQUEST_IN_PROGRESS: HTTPC_RequestStatus = 5;
pub const HTTPC_STATUS_DOWNLOAD_READY: HTTPC_RequestStatus = 7;
pub type HTTPC_RequestStatus = ::libc::c_uint;
pub const HTTPC_KEEPALIVE_DISABLED: HTTPC_KeepAlive = 0;
pub const HTTPC_KEEPALIVE_ENABLED: HTTPC_KeepAlive = 1;
pub type HTTPC_KeepAlive = ::libc::c_uint;
extern "C" {
    pub fn httpcInit(sharedmem_size: u32_) -> Result;
}
extern "C" {
    pub fn httpcExit();
}
extern "C" {
    pub fn httpcOpenContext(
        context: *mut httpcContext,
        method: HTTPC_RequestMethod,
        url: *const ::libc::c_char,
        use_defaultproxy: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcAddRequestHeaderField(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataAscii(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataBinary(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const u8_,
        len: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32_, len: u32_) -> Result;
}
extern "C" {
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    pub fn httpcReceiveDataTimeout(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetRequestState(
        context: *mut httpcContext,
        out: *mut HTTPC_RequestStatus,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetDownloadSizeState(
        context: *mut httpcContext,
        downloadedsize: *mut u32_,
        contentsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext, out: *mut u32_) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCodeTimeout(
        context: *mut httpcContext,
        out: *mut u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    pub fn httpcGetResponseHeader(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        valuebuf_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddTrustedRootCA(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcAddDefaultCert(context: *mut httpcContext, certID: SSLC_DefaultRootCert) -> Result;
}
extern "C" {
    pub fn httpcSelectRootCertChain(
        context: *mut httpcContext,
        RootCertChain_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCert(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCertDefault(
        context: *mut httpcContext,
        certID: SSLC_DefaultClientCert,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetClientCertContext(
        context: *mut httpcContext,
        ClientCert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddCert(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    pub fn httpcDownloadData(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        downloadedsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn httpcSetKeepAlive(context: *mut httpcContext, option: HTTPC_KeepAlive) -> Result;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64_,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16_,
    pub pad_x22: u16_,
    pub word_x24: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union udsNodeInfo__bindgen_ty_1 {
    pub usercfg: [u8_; 24usize],
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16_; 10usize],
    pub unk_x1c: u16_,
    pub flag: u8_,
    pub pad_x1f: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsConnectionStatus {
    pub status: u32_,
    pub unk_x4: u32_,
    pub cur_NetworkNodeID: u16_,
    pub unk_xa: u16_,
    pub unk_xc: [u32_; 8usize],
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub node_bitmask: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8_; 6usize],
    pub channel: u8_,
    pub pad_x7: u8_,
    pub initialized_flag: u8_,
    pub unk_x9: [u8_; 3usize],
    pub oui_value: [u8_; 3usize],
    pub oui_type: u8_,
    pub wlancommID: u32_,
    pub id8: u8_,
    pub unk_x15: u8_,
    pub attributes: u16_,
    pub networkID: u32_,
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub unk_x1e: u8_,
    pub unk_x1f: u8_,
    pub unk_x20: [u8_; 31usize],
    pub appdata_size: u8_,
    pub appdata: [u8_; 200usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsBindContext {
    pub BindNodeID: u32_,
    pub event: Handle,
    pub spectator: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16_,
    pub unk_x2: u16_,
    pub unk_x4: u16_,
    pub unk_x6: u16_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 38usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32_,
    pub size: u32_,
    pub total_entries: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32_,
    pub unk_x4: u8_,
    pub channel: u8_,
    pub unk_x6: u8_,
    pub unk_x7: u8_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 6usize],
    pub unk_x14: u32_,
    pub val_x1c: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
pub const UDSNETATTR_DisableConnectSpectators: ::libc::c_uint = 1;
pub const UDSNETATTR_DisableConnectClients: ::libc::c_uint = 2;
pub const UDSNETATTR_x4: ::libc::c_uint = 4;
pub const UDSNETATTR_Default: ::libc::c_uint = 32768;
pub type _bindgen_ty_24 = ::libc::c_uint;
pub const UDS_SENDFLAG_Default: ::libc::c_uint = 1;
pub const UDS_SENDFLAG_Broadcast: ::libc::c_uint = 2;
pub type _bindgen_ty_25 = ::libc::c_uint;
pub const UDSCONTYPE_Client: udsConnectionType = 1;
pub const UDSCONTYPE_Spectator: udsConnectionType = 2;
pub type udsConnectionType = ::libc::c_uint;
extern "C" {
    pub fn udsInit(sharedmem_size: size_t, username: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn udsExit();
}
extern "C" {
    pub fn udsGenerateNodeInfo(
        nodeinfo: *mut udsNodeInfo,
        username: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn udsGetNodeInfoUsername(
        nodeinfo: *const udsNodeInfo,
        username: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
extern "C" {
    pub fn udsGenerateDefaultNetworkStruct(
        network: *mut udsNetworkStruct,
        wlancommID: u32_,
        id8: u8_,
        max_nodes: u8_,
    );
}
extern "C" {
    pub fn udsScanBeacons(
        outbuf: *mut ::libc::c_void,
        maxsize: size_t,
        networks: *mut *mut udsNetworkScanInfo,
        total_networks: *mut size_t,
        wlancommID: u32_,
        id8: u8_,
        host_macaddress: *const u8_,
        connected: bool,
    ) -> Result;
}
extern "C" {
    pub fn udsSetApplicationData(buf: *const ::libc::c_void, size: size_t) -> Result;
}
extern "C" {
    pub fn udsGetApplicationData(
        buf: *mut ::libc::c_void,
        size: size_t,
        actual_size: *mut size_t,
    ) -> Result;
}
extern "C" {
    pub fn udsGetNetworkStructApplicationData(
        network: *const udsNetworkStruct,
        buf: *mut ::libc::c_void,
        size: size_t,
        actual_size: *mut size_t,
    ) -> Result;
}
extern "C" {
    pub fn udsBind(
        bindcontext: *mut udsBindContext,
        NetworkNodeID: u16_,
        spectator: bool,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
extern "C" {
    pub fn udsWaitDataAvailable(
        bindcontext: *const udsBindContext,
        nextEvent: bool,
        wait: bool,
    ) -> bool;
}
extern "C" {
    pub fn udsPullPacket(
        bindcontext: *const udsBindContext,
        buf: *mut ::libc::c_void,
        size: size_t,
        actual_size: *mut size_t,
        src_NetworkNodeID: *mut u16_,
    ) -> Result;
}
extern "C" {
    pub fn udsSendTo(
        dst_NetworkNodeID: u16_,
        data_channel: u8_,
        flags: u8_,
        buf: *const ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn udsGetChannel(channel: *mut u8_) -> Result;
}
extern "C" {
    pub fn udsCreateNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: size_t,
        context: *mut udsBindContext,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn udsConnectNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: size_t,
        context: *mut udsBindContext,
        recv_NetworkNodeID: u16_,
        connection_type: udsConnectionType,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn udsDestroyNetwork() -> Result;
}
extern "C" {
    pub fn udsDisconnectNetwork() -> Result;
}
extern "C" {
    pub fn udsEjectClient(NetworkNodeID: u16_) -> Result;
}
extern "C" {
    pub fn udsEjectSpectator() -> Result;
}
extern "C" {
    pub fn udsUpdateNetworkAttribute(bitmask: u16_, flag: bool) -> Result;
}
extern "C" {
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool) -> Result;
}
extern "C" {
    pub fn udsAllowSpectators() -> Result;
}
extern "C" {
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
extern "C" {
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    pub fn udsGetNodeInformation(NetworkNodeID: u16_, output: *mut udsNodeInfo) -> Result;
}
pub const NDM_EXCLUSIVE_STATE_NONE: ndmExclusiveState = 0;
pub const NDM_EXCLUSIVE_STATE_INFRASTRUCTURE: ndmExclusiveState = 1;
pub const NDM_EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS: ndmExclusiveState = 2;
pub const NDM_EXCLUSIVE_STATE_STREETPASS: ndmExclusiveState = 3;
pub const NDM_EXCLUSIVE_STATE_STREETPASS_DATA: ndmExclusiveState = 4;
pub type ndmExclusiveState = ::libc::c_uint;
pub const NDM_STATE_INITIAL: ndmState = 0;
pub const NDM_STATE_SUSPENDED: ndmState = 1;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTING: ndmState = 2;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTED: ndmState = 3;
pub const NDM_STATE_INFRASTRUCTURE_WORKING: ndmState = 4;
pub const NDM_STATE_INFRASTRUCTURE_SUSPENDING: ndmState = 5;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_SUSPENDING: ndmState = 6;
pub const NDM_STATE_INFRASTRUCTURE_DISCONNECTING: ndmState = 7;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_DISCONNECTING: ndmState = 8;
pub const NDM_STATE_CEC_WORKING: ndmState = 9;
pub const NDM_STATE_CEC_FORCE_SUSPENDING: ndmState = 10;
pub const NDM_STATE_CEC_SUSPENDING: ndmState = 11;
pub type ndmState = ::libc::c_uint;
pub const NDM_DAEMON_CEC: ndmDaemon = 0;
pub const NDM_DAEMON_BOSS: ndmDaemon = 1;
pub const NDM_DAEMON_NIM: ndmDaemon = 2;
pub const NDM_DAEMON_FRIENDS: ndmDaemon = 3;
pub type ndmDaemon = ::libc::c_uint;
pub const NDM_DAEMON_MASK_CEC: ndmDaemonMask = 1;
pub const NDM_DAEMON_MASK_BOSS: ndmDaemonMask = 2;
pub const NDM_DAEMON_MASK_NIM: ndmDaemonMask = 4;
pub const NDM_DAEMON_MASK_FRIENDS: ndmDaemonMask = 8;
pub const NDM_DAEMON_MASK_BACKGROUOND: ndmDaemonMask = 7;
pub const NDM_DAEMON_MASK_ALL: ndmDaemonMask = 15;
pub const NDM_DAEMON_MASK_DEFAULT: ndmDaemonMask = 9;
pub type ndmDaemonMask = ::libc::c_uint;
pub const NDM_DAEMON_STATUS_BUSY: ndmDaemonStatus = 0;
pub const NDM_DAEMON_STATUS_IDLE: ndmDaemonStatus = 1;
pub const NDM_DAEMON_STATUS_SUSPENDING: ndmDaemonStatus = 2;
pub const NDM_DAEMON_STATUS_SUSPENDED: ndmDaemonStatus = 3;
pub type ndmDaemonStatus = ::libc::c_uint;
extern "C" {
    pub fn ndmuInit() -> Result;
}
extern "C" {
    pub fn ndmuExit();
}
extern "C" {
    pub fn NDMU_EnterExclusiveState(state: ndmExclusiveState) -> Result;
}
extern "C" {
    pub fn NDMU_LeaveExclusiveState() -> Result;
}
extern "C" {
    pub fn NDMU_GetExclusiveState(state: *mut ndmExclusiveState) -> Result;
}
extern "C" {
    pub fn NDMU_LockState() -> Result;
}
extern "C" {
    pub fn NDMU_UnlockState() -> Result;
}
extern "C" {
    pub fn NDMU_SuspendDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_ResumeDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_SuspendScheduler(flag: u32_) -> Result;
}
extern "C" {
    pub fn NDMU_ResumeScheduler() -> Result;
}
extern "C" {
    pub fn NDMU_GetCurrentState(state: *mut ndmState) -> Result;
}
extern "C" {
    pub fn NDMU_QueryStatus(status: *mut ndmDaemonStatus) -> Result;
}
extern "C" {
    pub fn NDMU_SetScanInterval(interval: u32_) -> Result;
}
extern "C" {
    pub fn NDMU_GetScanInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    pub fn NDMU_GetRetryInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    pub fn NDMU_ResetDaemons() -> Result;
}
extern "C" {
    pub fn NDMU_GetDefaultDaemons(mask: *mut ndmDaemonMask) -> Result;
}
extern "C" {
    pub fn NDMU_ClearMacFilter() -> Result;
}
pub const IM_DEFAULT: NIM_InstallationMode = 0;
pub const IM_UNKNOWN1: NIM_InstallationMode = 1;
pub const IM_UNKNOWN2: NIM_InstallationMode = 2;
pub const IM_REINSTALL: NIM_InstallationMode = 3;
pub type NIM_InstallationMode = ::libc::c_uint;
pub const DS_NOT_INITIALIZED: NIM_DownloadState = 0;
pub const DS_INITIALIZED: NIM_DownloadState = 1;
pub const DS_DOWNLOAD_TMD: NIM_DownloadState = 2;
pub const DS_PREPARE_SAVE_DATA: NIM_DownloadState = 3;
pub const DS_DOWNLOAD_CONTENTS: NIM_DownloadState = 4;
pub const DS_WAIT_COMMIT: NIM_DownloadState = 5;
pub const DS_COMMITTING: NIM_DownloadState = 6;
pub const DS_FINISHED: NIM_DownloadState = 7;
pub const DS_VERSION_ERROR: NIM_DownloadState = 8;
pub const DS_CREATE_CONTEXT: NIM_DownloadState = 9;
pub const DS_CANNOT_RECOVER: NIM_DownloadState = 10;
pub const DS_INVALID: NIM_DownloadState = 11;
pub type NIM_DownloadState = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NIM_TitleConfig {
    pub titleId: u64_,
    pub version: u32_,
    pub unknown_0: u32_,
    pub ratingAge: u8_,
    pub mediaType: u8_,
    pub padding: [u8_; 2usize],
    pub unknown_1: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NIM_TitleProgress {
    pub state: u32_,
    pub lastResult: Result,
    pub downloadedSize: u64_,
    pub totalSize: u64_,
}
extern "C" {
    pub fn nimsInit(buffer: *mut ::libc::c_void, buffer_len: size_t) -> Result;
}
extern "C" {
    pub fn nimsInitWithTIN(
        buffer: *mut ::libc::c_void,
        buffer_len: size_t,
        TIN: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn nimsExit();
}
extern "C" {
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn NIMS_SetAttribute(attr: *const ::libc::c_char, val: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
extern "C" {
    pub fn NIMS_MakeTitleConfig(
        cfg: *mut NIM_TitleConfig,
        titleId: u64_,
        version: u32_,
        ratingAge: u8_,
        mediaType: FS_MediaType,
    );
}
extern "C" {
    pub fn NIMS_RegisterTask(
        cfg: *const NIM_TitleConfig,
        name: *const ::libc::c_char,
        maker: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn NIMS_IsTaskRegistered(titleId: u64_, registered: *mut bool) -> Result;
}
extern "C" {
    pub fn NIMS_UnregisterTask(titleId: u64_) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig, mode: NIM_InstallationMode) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
extern "C" {
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
extern "C" {
    pub fn NIMS_CancelDownload() -> Result;
}
extern "C" {
    pub fn nwmExtInit() -> Result;
}
extern "C" {
    pub fn nwmExtExit();
}
extern "C" {
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
extern "C" {
    pub fn iruInit(sharedmem_addr: *mut u32_, sharedmem_size: u32_) -> Result;
}
extern "C" {
    pub fn iruExit();
}
extern "C" {
    pub fn iruGetServHandle() -> Handle;
}
extern "C" {
    pub fn iruSendData(buf: *mut u8_, size: u32_, wait: bool) -> Result;
}
extern "C" {
    pub fn iruRecvData(
        buf: *mut u8_,
        size: u32_,
        flag: u8_,
        transfercount: *mut u32_,
        wait: bool,
    ) -> Result;
}
extern "C" {
    pub fn IRU_Initialize() -> Result;
}
extern "C" {
    pub fn IRU_Shutdown() -> Result;
}
extern "C" {
    pub fn IRU_StartSendTransfer(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    pub fn IRU_WaitSendTransfer() -> Result;
}
extern "C" {
    pub fn IRU_StartRecvTransfer(size: u32_, flag: u8_) -> Result;
}
extern "C" {
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32_) -> Result;
}
extern "C" {
    pub fn IRU_SetBitRate(value: u8_) -> Result;
}
extern "C" {
    pub fn IRU_GetBitRate(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn IRU_SetIRLEDState(value: u32_) -> Result;
}
extern "C" {
    pub fn IRU_GetIRLEDRecvState(out: *mut u32_) -> Result;
}
extern "C" {
    pub fn IRU_GetSendFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    pub fn IRU_GetRecvFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    pub fn nsInit() -> Result;
}
extern "C" {
    pub fn nsExit();
}
extern "C" {
    pub fn NS_LaunchFIRM(titleid: u64_) -> Result;
}
extern "C" {
    pub fn NS_LaunchTitle(titleid: u64_, launch_flags: u32_, procid: *mut u32_) -> Result;
}
extern "C" {
    pub fn NS_TerminateTitle() -> Result;
}
extern "C" {
    pub fn NS_LaunchApplicationFIRM(titleid: u64_, flags: u32_) -> Result;
}
extern "C" {
    pub fn NS_RebootToTitle(mediatype: u8_, titleid: u64_) -> Result;
}
extern "C" {
    pub fn NS_TerminateProcessTID(titleid: u64_, timeout: u64_) -> Result;
}
extern "C" {
    pub fn NS_RebootSystem() -> Result;
}
pub const PMLAUNCHFLAG_NORMAL_APPLICATION: ::libc::c_uint = 1;
pub const PMLAUNCHFLAG_LOAD_DEPENDENCIES: ::libc::c_uint = 2;
pub const PMLAUNCHFLAG_NOTIFY_TERMINATION: ::libc::c_uint = 4;
pub const PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION: ::libc::c_uint = 8;
pub const PMLAUNCHFLAG_TERMINATION_NOTIFICATION_MASK: ::libc::c_uint = 240;
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM: ::libc::c_uint = 256;
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM: ::libc::c_uint = 512;
pub const PMLAUNCHFLAG_USE_UPDATE_TITLE: ::libc::c_uint = 65536;
pub type _bindgen_ty_26 = ::libc::c_uint;
extern "C" {
    pub fn pmAppInit() -> Result;
}
extern "C" {
    pub fn pmAppExit();
}
extern "C" {
    pub fn pmAppGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PMAPP_LaunchTitle(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    pub fn PMAPP_LaunchTitleUpdate(
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn PMAPP_GetTitleExheaderFlags(
        outCoreInfo: *mut ExHeader_Arm11CoreInfo,
        outSiFlags: *mut ExHeader_SystemInfoFlags,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn PMAPP_SetFIRMLaunchParams(size: u32_, in_: *const ::libc::c_void) -> Result;
}
extern "C" {
    pub fn PMAPP_GetFIRMLaunchParams(out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn PMAPP_LaunchFIRMSetParams(
        firmTidLow: u32_,
        size: u32_,
        in_: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    pub fn PMAPP_PrepareForReboot(timeout: s64) -> Result;
}
extern "C" {
    pub fn PMAPP_TerminateCurrentApplication(timeout: s64) -> Result;
}
extern "C" {
    pub fn PMAPP_TerminateTitle(titleId: u64_, timeout: s64) -> Result;
}
extern "C" {
    pub fn PMAPP_TerminateProcess(pid: u32_, timeout: s64) -> Result;
}
extern "C" {
    pub fn PMAPP_UnregisterProcess(tid: u64_) -> Result;
}
extern "C" {
    pub fn PMAPP_SetAppResourceLimit(cpuTime: s64) -> Result;
}
extern "C" {
    pub fn PMAPP_GetAppResourceLimit(outCpuTime: *mut s64) -> Result;
}
extern "C" {
    pub fn pmDbgInit() -> Result;
}
extern "C" {
    pub fn pmDbgExit();
}
extern "C" {
    pub fn pmDbgGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PMDBG_LaunchAppDebug(
        outDebug: *mut Handle,
        programInfo: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn PMDBG_LaunchApp(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    pub fn PMDBG_RunQueuedProcess(outDebug: *mut Handle) -> Result;
}
pub const PS_ALGORITHM_CBC_ENC: PS_AESAlgorithm = 0;
pub const PS_ALGORITHM_CBC_DEC: PS_AESAlgorithm = 1;
pub const PS_ALGORITHM_CTR_ENC: PS_AESAlgorithm = 2;
pub const PS_ALGORITHM_CTR_DEC: PS_AESAlgorithm = 3;
pub const PS_ALGORITHM_CCM_ENC: PS_AESAlgorithm = 4;
pub const PS_ALGORITHM_CCM_DEC: PS_AESAlgorithm = 5;
pub type PS_AESAlgorithm = ::libc::c_uint;
pub const PS_KEYSLOT_0D: PS_AESKeyType = 0;
pub const PS_KEYSLOT_2D: PS_AESKeyType = 1;
pub const PS_KEYSLOT_31: PS_AESKeyType = 2;
pub const PS_KEYSLOT_38: PS_AESKeyType = 3;
pub const PS_KEYSLOT_32: PS_AESKeyType = 4;
pub const PS_KEYSLOT_39_DLP: PS_AESKeyType = 5;
pub const PS_KEYSLOT_2E: PS_AESKeyType = 6;
pub const PS_KEYSLOT_INVALID: PS_AESKeyType = 7;
pub const PS_KEYSLOT_36: PS_AESKeyType = 8;
pub const PS_KEYSLOT_39_NFC: PS_AESKeyType = 9;
pub type PS_AESKeyType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psRSAContext {
    pub modulo: [u8_; 256usize],
    pub exponent: [u8_; 256usize],
    pub rsa_bitsize: u32_,
    pub unk: u32_,
}
extern "C" {
    pub fn psInit() -> Result;
}
extern "C" {
    pub fn psInitHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn psExit();
}
extern "C" {
    pub fn psGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn PS_SignRsaSha256(hash: *mut u8_, ctx: *mut psRSAContext, signature: *mut u8_) -> Result;
}
extern "C" {
    pub fn PS_VerifyRsaSha256(
        hash: *mut u8_,
        ctx: *mut psRSAContext,
        signature: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn PS_EncryptDecryptAes(
        size: u32_,
        in_: *mut u8_,
        out: *mut u8_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        iv: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn PS_EncryptSignDecryptVerifyAesCcm(
        in_: *mut u8_,
        in_size: u32_,
        out: *mut u8_,
        out_size: u32_,
        data_len: u32_,
        mac_data_len: u32_,
        mac_len: u32_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        nonce: *mut u8_,
    ) -> Result;
}
extern "C" {
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    pub fn PS_GetDeviceId(device_id: *mut u32_) -> Result;
}
extern "C" {
    pub fn PS_GenerateRandomBytes(out: *mut ::libc::c_void, len: size_t) -> Result;
}
extern "C" {
    pub fn ptmuInit() -> Result;
}
extern "C" {
    pub fn ptmuExit();
}
extern "C" {
    pub fn ptmuGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PTMU_GetShellState(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryLevel(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryChargeState(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn PTMU_GetPedometerState(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn PTMU_GetTotalStepCount(steps: *mut u32_) -> Result;
}
extern "C" {
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PtmWakeEvents {
    pub pdn_wake_events: u32_,
    pub mcu_interupt_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PtmSleepConfig {
    pub exit_sleep_events: PtmWakeEvents,
    pub continue_sleep_events: PtmWakeEvents,
}
pub const PTMNOTIFID_SLEEP_REQUESTED: ::libc::c_uint = 257;
pub const PTMNOTIFID_SLEEP_DENIED: ::libc::c_uint = 258;
pub const PTMNOTIFID_SLEEP_ALLOWED: ::libc::c_uint = 259;
pub const PTMNOTIFID_GOING_TO_SLEEP: ::libc::c_uint = 260;
pub const PTMNOTIFID_FULLY_WAKING_UP: ::libc::c_uint = 261;
pub const PTMNOTIFID_FULLY_AWAKE: ::libc::c_uint = 262;
pub const PTMNOTIFID_HALF_AWAKE: ::libc::c_uint = 263;
pub const PTMNOTIFID_SHUTDOWN: ::libc::c_uint = 264;
pub const PTMNOTIFID_BATTERY_VERY_LOW: ::libc::c_uint = 529;
pub const PTMNOTIFID_BATTERY_LOW: ::libc::c_uint = 530;
pub type _bindgen_ty_27 = ::libc::c_uint;
extern "C" {
    pub fn ptmSysmInit() -> Result;
}
extern "C" {
    pub fn ptmSysmExit();
}
extern "C" {
    pub fn ptmSysmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PTMSYSM_RequestSleep() -> Result;
}
extern "C" {
    pub fn PTMSYSM_ReplyToSleepQuery(deny: bool) -> Result;
}
extern "C" {
    pub fn PTMSYSM_NotifySleepPreparationComplete(ackValue: s32) -> Result;
}
extern "C" {
    pub fn PTMSYSM_SetWakeEvents(sleepConfig: *const PtmSleepConfig) -> Result;
}
extern "C" {
    pub fn PTMSYSM_GetWakeReason(outSleepConfig: *mut PtmSleepConfig) -> Result;
}
extern "C" {
    pub fn PTMSYSM_Awaken() -> Result;
}
extern "C" {
    pub fn PTMSYSM_SetUserTime(msY2k: s64) -> Result;
}
extern "C" {
    pub fn PTMSYSM_InvalidateSystemTime() -> Result;
}
extern "C" {
    pub fn PTMSYSM_GetRtcTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    pub fn PTMSYSM_SetRtcTime(msY2k: s64) -> Result;
}
extern "C" {
    pub fn PTMSYSM_CheckNew3DS() -> Result;
}
extern "C" {
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8_) -> Result;
}
extern "C" {
    pub fn PTMSYSM_ShutdownAsync(timeout: u64_) -> Result;
}
extern "C" {
    pub fn PTMSYSM_RebootAsync(timeout: u64_) -> Result;
}
extern "C" {
    pub fn ptmGetsInit() -> Result;
}
extern "C" {
    pub fn ptmGetsExit();
}
extern "C" {
    pub fn ptmGetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PTMGETS_GetSystemTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    pub fn ptmSetsInit() -> Result;
}
extern "C" {
    pub fn ptmSetsExit();
}
extern "C" {
    pub fn ptmSetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PTMSETS_SetSystemTime(msY2k: s64) -> Result;
}
pub const WAIT_NONE: PXIDEV_WaitType = 0;
pub const WAIT_SLEEP: PXIDEV_WaitType = 1;
pub const WAIT_IREQ_RETURN: PXIDEV_WaitType = 2;
pub const WAIT_IREQ_CONTINUE: PXIDEV_WaitType = 3;
pub type PXIDEV_WaitType = ::libc::c_uint;
pub const DEASSERT_NONE: PXIDEV_DeassertType = 0;
pub const DEASSERT_BEFORE_WAIT: PXIDEV_DeassertType = 1;
pub const DEASSERT_AFTER_WAIT: PXIDEV_DeassertType = 2;
pub type PXIDEV_DeassertType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PXIDEV_SPIBuffer {
    pub ptr: *mut ::libc::c_void,
    pub size: u32_,
    pub transferOption: u8_,
    pub waitOperation: u64_,
}
extern "C" {
    pub fn pxiDevInit() -> Result;
}
extern "C" {
    pub fn pxiDevExit();
}
extern "C" {
    pub fn PXIDEV_SPIMultiWriteRead(
        header: *mut PXIDEV_SPIBuffer,
        writeBuffer1: *mut PXIDEV_SPIBuffer,
        readBuffer1: *mut PXIDEV_SPIBuffer,
        writeBuffer2: *mut PXIDEV_SPIBuffer,
        readBuffer2: *mut PXIDEV_SPIBuffer,
        footer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    pub fn PXIDEV_SPIWriteRead(
        bytesRead: *mut u32_,
        initialWaitOperation: u64_,
        writeBuffer: *mut PXIDEV_SPIBuffer,
        readBuffer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    pub fn pxiPmInit() -> Result;
}
extern "C" {
    pub fn pxiPmExit();
}
extern "C" {
    pub fn pxiPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn PXIPM_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
extern "C" {
    pub fn PXIPM_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        updateInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn PXIPM_UnregisterProgram(programHandle: u64_) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __ULong = ::libc::c_ulong;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: size_t,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: size_t,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_value: sigval,
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: size_t,
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::libc::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::libc::c_int, arg3: sigval) -> ::libc::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn str2sig(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
pub type sig_atomic_t = ::libc::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn signal(arg1: ::libc::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::libc::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::libc::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::libc::c_char; 26usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bind(sockfd: ::libc::c_int, addr: *const sockaddr, addrlen: socklen_t) -> ::libc::c_int;
}
extern "C" {
    pub fn closesocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::libc::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::libc::c_int, backlog: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: size_t,
        flags: ::libc::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: size_t,
        flags: ::libc::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn send(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: size_t,
        flags: ::libc::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: size_t,
        flags: ::libc::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *const ::libc::c_void,
        optlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::libc::c_int, how: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::libc::c_int,
        type_: ::libc::c_int,
        protocol: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::libc::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
pub const NETOPT_MAC_ADDRESS: NetworkOpt = 4100;
pub const NETOPT_ARP_TABLE: NetworkOpt = 12290;
pub const NETOPT_IP_INFO: NetworkOpt = 16387;
pub const NETOPT_IP_MTU: NetworkOpt = 16388;
pub const NETOPT_ROUTING_TABLE: NetworkOpt = 16390;
pub const NETOPT_UDP_NUMBER: NetworkOpt = 32770;
pub const NETOPT_UDP_TABLE: NetworkOpt = 32771;
pub const NETOPT_TCP_NUMBER: NetworkOpt = 36866;
pub const NETOPT_TCP_TABLE: NetworkOpt = 36867;
pub const NETOPT_DNS_TABLE: NetworkOpt = 45059;
pub const NETOPT_DHCP_LEASE_TIME: NetworkOpt = 49153;
pub type NetworkOpt = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32_,
    pub ip: in_addr,
    pub mac: [u8_; 6usize],
    pub padding: [u8_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_IPInfo {
    pub ip: in_addr,
    pub netmask: in_addr,
    pub broadcast: in_addr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_RoutingTableEntry {
    pub dest_ip: in_addr,
    pub netmask: in_addr,
    pub gateway: in_addr,
    pub flags: u32_,
    pub time: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_UDPTableEntry {
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_TCPTableEntry {
    pub state: u32_,
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SOCU_DNSTableEntry {
    pub family: u32_,
    pub ip: in_addr,
    pub padding: [u8_; 12usize],
}
extern "C" {
    pub fn socInit(context_addr: *mut u32_, context_size: u32_) -> Result;
}
extern "C" {
    pub fn socExit() -> Result;
}
extern "C" {
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn gethostname(name: *mut ::libc::c_char, namelen: size_t) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_ShutdownSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_CloseSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_GetNetworkOpt(
        level: ::libc::c_int,
        optname: NetworkOpt,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_GetIPInfo(
        ip: *mut in_addr,
        netmask: *mut in_addr,
        broadcast: *mut in_addr,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_AddGlobalSocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
pub const MICU_ENCODING_PCM8: MICU_Encoding = 0;
pub const MICU_ENCODING_PCM16: MICU_Encoding = 1;
pub const MICU_ENCODING_PCM8_SIGNED: MICU_Encoding = 2;
pub const MICU_ENCODING_PCM16_SIGNED: MICU_Encoding = 3;
pub type MICU_Encoding = ::libc::c_uint;
pub const MICU_SAMPLE_RATE_32730: MICU_SampleRate = 0;
pub const MICU_SAMPLE_RATE_16360: MICU_SampleRate = 1;
pub const MICU_SAMPLE_RATE_10910: MICU_SampleRate = 2;
pub const MICU_SAMPLE_RATE_8180: MICU_SampleRate = 3;
pub type MICU_SampleRate = ::libc::c_uint;
extern "C" {
    pub fn micInit(buffer: *mut u8_, bufferSize: u32_) -> Result;
}
extern "C" {
    pub fn micExit();
}
extern "C" {
    pub fn micGetSampleDataSize() -> u32_;
}
extern "C" {
    pub fn micGetLastSampleOffset() -> u32_;
}
extern "C" {
    pub fn MICU_MapSharedMem(size: u32_, handle: Handle) -> Result;
}
extern "C" {
    pub fn MICU_UnmapSharedMem() -> Result;
}
extern "C" {
    pub fn MICU_StartSampling(
        encoding: MICU_Encoding,
        sampleRate: MICU_SampleRate,
        offset: u32_,
        size: u32_,
        loop_: bool,
    ) -> Result;
}
extern "C" {
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
extern "C" {
    pub fn MICU_StopSampling() -> Result;
}
extern "C" {
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
extern "C" {
    pub fn MICU_SetGain(gain: u8_) -> Result;
}
extern "C" {
    pub fn MICU_GetGain(gain: *mut u8_) -> Result;
}
extern "C" {
    pub fn MICU_SetPower(power: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
pub const MVDMODE_COLORFORMATCONV: MVDSTD_Mode = 0;
pub const MVDMODE_VIDEOPROCESSING: MVDSTD_Mode = 1;
pub type MVDSTD_Mode = ::libc::c_uint;
pub const MVD_INPUT_YUYV422: MVDSTD_InputFormat = 65537;
pub const MVD_INPUT_H264: MVDSTD_InputFormat = 131073;
pub type MVDSTD_InputFormat = ::libc::c_uint;
pub const MVD_OUTPUT_YUYV422: MVDSTD_OutputFormat = 65537;
pub const MVD_OUTPUT_BGR565: MVDSTD_OutputFormat = 262146;
pub const MVD_OUTPUT_RGB565: MVDSTD_OutputFormat = 262148;
pub type MVDSTD_OutputFormat = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_Config {
    pub input_type: MVDSTD_InputFormat,
    pub unk_x04: u32_,
    pub unk_x08: u32_,
    pub inwidth: u32_,
    pub inheight: u32_,
    pub physaddr_colorconv_indata: u32_,
    pub physaddr_colorconv_unk0: u32_,
    pub physaddr_colorconv_unk1: u32_,
    pub physaddr_colorconv_unk2: u32_,
    pub physaddr_colorconv_unk3: u32_,
    pub unk_x28: [u32_; 6usize],
    pub enable_cropping: u32_,
    pub input_crop_x_pos: u32_,
    pub input_crop_y_pos: u32_,
    pub input_crop_height: u32_,
    pub input_crop_width: u32_,
    pub unk_x54: u32_,
    pub output_type: MVDSTD_OutputFormat,
    pub outwidth: u32_,
    pub outheight: u32_,
    pub physaddr_outdata0: u32_,
    pub physaddr_outdata1: u32_,
    pub unk_x6c: [u32_; 38usize],
    pub flag_x104: u32_,
    pub output_x_pos: u32_,
    pub output_y_pos: u32_,
    pub output_width_override: u32_,
    pub output_height_override: u32_,
    pub unk_x118: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32_,
    pub end_physaddr: u32_,
    pub remaining_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut ::libc::c_void,
    pub outdata1: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32_,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32_,
    pub cmd1b_inval: u8_,
}
extern "C" {
    pub fn mvdstdInit(
        mode: MVDSTD_Mode,
        input_type: MVDSTD_InputFormat,
        output_type: MVDSTD_OutputFormat,
        size: u32_,
        initstruct: *mut MVDSTD_InitStruct,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdExit();
}
extern "C" {
    pub fn mvdstdGenerateDefaultConfig(
        config: *mut MVDSTD_Config,
        input_width: u32_,
        input_height: u32_,
        output_width: u32_,
        output_height: u32_,
        vaddr_colorconv_indata: *mut u32_,
        vaddr_outdata0: *mut u32_,
        vaddr_outdata1: *mut u32_,
    );
}
extern "C" {
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdProcessVideoFrame(
        inbuf_vaddr: *mut ::libc::c_void,
        size: size_t,
        flag: u32_,
        out: *mut MVDSTD_ProcessNALUnitOut,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool) -> Result;
}
extern "C" {
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdSetupOutputBuffers(
        entrylist: *mut MVDSTD_OutputBuffersEntryList,
        bufsize: u32_,
    ) -> Result;
}
extern "C" {
    pub fn mvdstdOverrideOutputBuffers(
        cur_outdata0: *mut ::libc::c_void,
        cur_outdata1: *mut ::libc::c_void,
        new_outdata0: *mut ::libc::c_void,
        new_outdata1: *mut ::libc::c_void,
    ) -> Result;
}
pub const NFC_OpType_1: NFC_OpType = 1;
pub const NFC_OpType_NFCTag: NFC_OpType = 2;
pub const NFC_OpType_RawNFC: NFC_OpType = 3;
pub type NFC_OpType = ::libc::c_uint;
pub const NFC_TagState_Uninitialized: NFC_TagState = 0;
pub const NFC_TagState_ScanningStopped: NFC_TagState = 1;
pub const NFC_TagState_Scanning: NFC_TagState = 2;
pub const NFC_TagState_InRange: NFC_TagState = 3;
pub const NFC_TagState_OutOfRange: NFC_TagState = 4;
pub const NFC_TagState_DataReady: NFC_TagState = 5;
pub type NFC_TagState = ::libc::c_uint;
pub const NFC_amiiboFlag_Setup: ::libc::c_uint = 16;
pub const NFC_amiiboFlag_AppDataSetup: ::libc::c_uint = 32;
pub type _bindgen_ty_28 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16_,
    pub unk_x2: u8_,
    pub unk_x3: u8_,
    pub id: [u8_; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8_; 96usize],
    pub nickname: [u16_; 11usize],
    pub flags: u8_,
    pub countrycodeid: u8_,
    pub setupdate_year: u16_,
    pub setupdate_month: u8_,
    pub setupdate_day: u8_,
    pub unk_x7c: [u8_; 44usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16_,
    pub lastwritedate_month: u8_,
    pub lastwritedate_day: u8_,
    pub write_counter: u16_,
    pub characterID: [u8_; 3usize],
    pub series: u8_,
    pub amiiboID: u16_,
    pub type_: u8_,
    pub pagex4_byte3: u8_,
    pub appdata_size: u16_,
    pub zeros: [u8_; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8_; 12usize],
    pub data_xc: [u8_; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8_; 10usize],
    pub id_size: u8_,
    pub unused_xb: [u8_; 21usize],
}
extern "C" {
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
extern "C" {
    pub fn nfcExit();
}
extern "C" {
    pub fn nfcGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn nfcStartScanning(inval: u16_) -> Result;
}
extern "C" {
    pub fn nfcStopScanning();
}
extern "C" {
    pub fn nfcLoadAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcResetTagScanState() -> Result;
}
extern "C" {
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
extern "C" {
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    pub fn nfcOpenAppData(amiibo_appid: u32_) -> Result;
}
extern "C" {
    pub fn nfcInitializeWriteAppData(
        amiibo_appid: u32_,
        buf: *const ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn nfcReadAppData(buf: *mut ::libc::c_void, size: size_t) -> Result;
}
extern "C" {
    pub fn nfcWriteAppData(
        buf: *const ::libc::c_void,
        size: size_t,
        taginfo: *mut NFC_TagInfo,
    ) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
extern "C" {
    pub fn nfcStartOtherTagScanning(unk0: u16_, unk1: u32_) -> Result;
}
extern "C" {
    pub fn nfcSendTagCommand(
        inbuf: *const ::libc::c_void,
        insize: size_t,
        outbuf: *mut ::libc::c_void,
        outsize: size_t,
        actual_transfer_size: *mut size_t,
        microseconds: u64_,
    ) -> Result;
}
extern "C" {
    pub fn nfcCmd21() -> Result;
}
extern "C" {
    pub fn nfcCmd22() -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8_; 3usize],
    pub processID: u64_,
    pub unkData2: [u8_; 8usize],
    pub jumpParam: u64_,
    pub unkData3: [u8_; 8usize],
    pub time: u64_,
    pub title: [u16_; 32usize],
}
extern "C" {
    pub fn newsInit() -> Result;
}
extern "C" {
    pub fn newsExit();
}
extern "C" {
    pub fn NEWS_AddNotification(
        title: *const u16_,
        titleLength: u32_,
        message: *const u16_,
        messageLength: u32_,
        imageData: *const ::libc::c_void,
        imageSize: u32_,
        jpeg: bool,
    ) -> Result;
}
extern "C" {
    pub fn NEWS_GetTotalNotifications(num: *mut u32_) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationHeader(news_id: u32_, header: *const NotificationHeader) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationHeader(news_id: u32_, header: *mut NotificationHeader) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationMessage(news_id: u32_, message: *const u16_, size: u32_) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationMessage(
        news_id: u32_,
        message: *mut u16_,
        size: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationImage(
        news_id: u32_,
        buffer: *const ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationImage(
        news_id: u32_,
        buffer: *mut ::libc::c_void,
        size: *mut u32_,
    ) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTM_HeadTrackingInfoCoord {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTM_HeadTrackingInfo {
    pub flags: [u8_; 5usize],
    pub padding: [u8_; 3usize],
    pub floatdata_x08: f32,
    pub coords0: [QTM_HeadTrackingInfoCoord; 4usize],
    pub unk_x2c: [u32_; 5usize],
}
extern "C" {
    pub fn qtmInit() -> Result;
}
extern "C" {
    pub fn qtmExit();
}
extern "C" {
    pub fn qtmCheckInitialized() -> bool;
}
extern "C" {
    pub fn qtmCheckHeadFullyDetected(info: *mut QTM_HeadTrackingInfo) -> bool;
}
extern "C" {
    pub fn qtmConvertCoordToScreen(
        coord: *mut QTM_HeadTrackingInfoCoord,
        screen_width: *mut f32,
        screen_height: *mut f32,
        x: *mut u32_,
        y: *mut u32_,
    ) -> Result;
}
extern "C" {
    pub fn QTM_GetHeadTrackingInfo(val: u64_, out: *mut QTM_HeadTrackingInfo) -> Result;
}
extern "C" {
    pub fn srvPmInit() -> Result;
}
extern "C" {
    pub fn srvPmExit();
}
extern "C" {
    pub fn srvPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn SRVPM_PublishToProcess(notificationId: u32_, process: Handle) -> Result;
}
extern "C" {
    pub fn SRVPM_PublishToAll(notificationId: u32_) -> Result;
}
extern "C" {
    pub fn SRVPM_RegisterProcess(
        pid: u32_,
        count: u32_,
        serviceAccessControlList: *const [::libc::c_char; 8usize],
    ) -> Result;
}
extern "C" {
    pub fn SRVPM_UnregisterProcess(pid: u32_) -> Result;
}
extern "C" {
    pub fn loaderInit() -> Result;
}
extern "C" {
    pub fn loaderExit();
}
extern "C" {
    pub fn LOADER_LoadProcess(process: *mut Handle, programHandle: u64_) -> Result;
}
extern "C" {
    pub fn LOADER_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    pub fn LOADER_UnregisterProgram(programHandle: u64_) -> Result;
}
extern "C" {
    pub fn LOADER_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
pub const LED_NORMAL: powerLedState = 1;
pub const LED_SLEEP_MODE: powerLedState = 2;
pub const LED_OFF: powerLedState = 3;
pub const LED_RED: powerLedState = 4;
pub const LED_BLUE: powerLedState = 5;
pub const LED_BLINK_RED: powerLedState = 6;
pub type powerLedState = ::libc::c_uint;
extern "C" {
    pub fn mcuHwcInit() -> Result;
}
extern "C" {
    pub fn mcuHwcExit();
}
extern "C" {
    pub fn mcuHwcGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn MCUHWC_ReadRegister(reg: u8_, data: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn MCUHWC_WriteRegister(reg: u8_, data: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetBatteryVoltage(voltage: *mut u8_) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetBatteryLevel(level: *mut u8_) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetSoundSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    pub fn MCUHWC_SetWifiLedState(state: bool) -> Result;
}
extern "C" {
    pub fn MCUHWC_SetPowerLedState(state: powerLedState) -> Result;
}
extern "C" {
    pub fn MCUHWC_Get3dSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetFwVerHigh(out: *mut u8_) -> Result;
}
extern "C" {
    pub fn MCUHWC_GetFwVerLow(out: *mut u8_) -> Result;
}
pub const CODEC_I2S_LINE_1: CodecI2sLine = 0;
pub const CODEC_I2S_LINE_2: CodecI2sLine = 1;
pub type CodecI2sLine = ::libc::c_uint;
extern "C" {
    pub fn cdcChkInit() -> Result;
}
extern "C" {
    pub fn cdcChkExit();
}
extern "C" {
    pub fn cdcChkGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn CDCCHK_ReadRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn CDCCHK_ReadRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn CDCCHK_WriteRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn CDCCHK_WriteRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: size_t,
    ) -> Result;
}
extern "C" {
    pub fn CDCCHK_ReadNtrPmicRegister(outData: *mut u8_, regAddr: u8_) -> Result;
}
extern "C" {
    pub fn CDCCHK_WriteNtrPmicRegister(regAddr: u8_, data: u8_) -> Result;
}
extern "C" {
    pub fn CDCCHK_SetI2sVolume(i2sLine: CodecI2sLine, volume: s8) -> Result;
}
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
pub type GX_TRANSFER_FORMAT = ::libc::c_uint;
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
pub type GX_TRANSFER_SCALE = ::libc::c_uint;
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
pub type GX_FILL_CONTROL = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union gxCmdEntry_s {
    pub data: [u32_; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    pub type_: u8_,
    pub unk1: u8_,
    pub unk2: u8_,
    pub unk3: u8_,
    pub args: [u32_; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_gxCmdQueue_s {
    pub entries: *mut gxCmdEntry_s,
    pub maxEntries: u16_,
    pub numEntries: u16_,
    pub curEntry: u16_,
    pub lastEntry: u16_,
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    pub user: *mut ::libc::c_void,
}
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s, entry: *const gxCmdEntry_s);
}
extern "C" {
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
extern "C" {
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn GX_RequestDma(src: *mut u32_, dst: *mut u32_, length: u32_) -> Result;
}
extern "C" {
    pub fn GX_ProcessCommandList(buf0a: *mut u32_, buf0s: u32_, flags: u8_) -> Result;
}
extern "C" {
    pub fn GX_MemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    ) -> Result;
}
extern "C" {
    pub fn GX_DisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn GX_TextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32_,
        buf0s: u32_,
        buf1a: *mut u32_,
        buf1s: u32_,
        buf2a: *mut u32_,
        buf2s: u32_,
    ) -> Result;
}
pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
pub type GPU_TEXTURE_FILTER_PARAM = ::libc::c_uint;
pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
pub type GPU_TEXTURE_WRAP_PARAM = ::libc::c_uint;
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uint;
pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
pub type GPU_TEXUNIT = ::libc::c_uint;
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
pub const GPU_LA8: GPU_TEXCOLOR = 5;
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
pub const GPU_L8: GPU_TEXCOLOR = 7;
pub const GPU_A8: GPU_TEXCOLOR = 8;
pub const GPU_LA4: GPU_TEXCOLOR = 9;
pub const GPU_L4: GPU_TEXCOLOR = 10;
pub const GPU_A4: GPU_TEXCOLOR = 11;
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
pub type GPU_TEXCOLOR = ::libc::c_uint;
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
pub type GPU_TEXFACE = ::libc::c_uint;
pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
pub type GPU_PROCTEX_CLAMP = ::libc::c_uint;
pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
pub type GPU_PROCTEX_MAPFUNC = ::libc::c_uint;
pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
pub type GPU_PROCTEX_SHIFT = ::libc::c_uint;
pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
pub type GPU_PROCTEX_FILTER = ::libc::c_uint;
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
pub type GPU_PROCTEX_LUTID = ::libc::c_uint;
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
pub type GPU_COLORBUF = ::libc::c_uint;
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
pub type GPU_DEPTHBUF = ::libc::c_uint;
pub const GPU_NEVER: GPU_TESTFUNC = 0;
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
pub const GPU_LESS: GPU_TESTFUNC = 4;
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
pub const GPU_GREATER: GPU_TESTFUNC = 6;
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
pub type GPU_TESTFUNC = ::libc::c_uint;
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
pub type GPU_EARLYDEPTHFUNC = ::libc::c_uint;
pub const GPU_GAS_NEVER: GPU_GASDEPTHFUNC = 0;
pub const GPU_GAS_ALWAYS: GPU_GASDEPTHFUNC = 1;
pub const GPU_GAS_GREATER: GPU_GASDEPTHFUNC = 2;
pub const GPU_GAS_LESS: GPU_GASDEPTHFUNC = 3;
pub type GPU_GASDEPTHFUNC = ::libc::c_uint;
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
pub type GPU_SCISSORMODE = ::libc::c_uint;
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
pub type GPU_STENCILOP = ::libc::c_uint;
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
pub type GPU_WRITEMASK = ::libc::c_uint;
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
pub type GPU_BLENDEQUATION = ::libc::c_uint;
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
pub type GPU_BLENDFACTOR = ::libc::c_uint;
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
pub type GPU_LOGICOP = ::libc::c_uint;
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
pub type GPU_FRAGOPMODE = ::libc::c_uint;
pub const GPU_BYTE: GPU_FORMATS = 0;
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
pub const GPU_SHORT: GPU_FORMATS = 2;
pub const GPU_FLOAT: GPU_FORMATS = 3;
pub type GPU_FORMATS = ::libc::c_uint;
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
pub type GPU_CULLMODE = ::libc::c_uint;
pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
pub const GPU_CONSTANT: GPU_TEVSRC = 14;
pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
pub type GPU_TEVSRC = ::libc::c_uint;
pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
pub type GPU_TEVOP_RGB = ::libc::c_uint;
pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
pub type GPU_TEVOP_A = ::libc::c_uint;
pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
pub const GPU_ADD: GPU_COMBINEFUNC = 2;
pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
pub type GPU_COMBINEFUNC = ::libc::c_uint;
pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
pub type GPU_TEVSCALE = ::libc::c_uint;
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
pub type GPU_FRESNELSEL = ::libc::c_uint;
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
pub type GPU_BUMPMODE = ::libc::c_uint;
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
pub type GPU_LIGHTLUTID = ::libc::c_uint;
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
pub type GPU_LIGHTLUTINPUT = ::libc::c_uint;
pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
pub type GPU_LIGHTLUTSCALER = ::libc::c_uint;
pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
pub type GPU_LIGHTLUTSELECT = ::libc::c_uint;
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
pub const GPU_FOG: GPU_FOGMODE = 5;
pub const GPU_GAS: GPU_FOGMODE = 7;
pub type GPU_FOGMODE = ::libc::c_uint;
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
pub type GPU_GASMODE = ::libc::c_uint;
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
pub type GPU_GASLUTINPUT = ::libc::c_uint;
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
pub type GPU_Primitive_t = ::libc::c_uint;
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
pub type GPU_SHADER_TYPE = ::libc::c_uint;
extern "C" {
    pub static mut gpuCmdBuf: *mut u32_;
}
extern "C" {
    pub static mut gpuCmdBufSize: u32_;
}
extern "C" {
    pub static mut gpuCmdBufOffset: u32_;
}
extern "C" {
    pub fn GPUCMD_AddRawCommands(cmd: *const u32_, size: u32_);
}
extern "C" {
    pub fn GPUCMD_Add(header: u32_, param: *const u32_, paramlength: u32_);
}
extern "C" {
    pub fn GPUCMD_Split(addr: *mut *mut u32_, size: *mut u32_);
}
extern "C" {
    pub fn f32tof16(f: f32) -> u32_;
}
extern "C" {
    pub fn f32tof20(f: f32) -> u32_;
}
extern "C" {
    pub fn f32tof24(f: f32) -> u32_;
}
extern "C" {
    pub fn f32tof31(f: f32) -> u32_;
}
pub const VERTEX_SHDR: DVLE_type = 0;
pub const GEOMETRY_SHDR: DVLE_type = 1;
pub type DVLE_type = ::libc::c_uint;
pub const DVLE_CONST_BOOL: DVLE_constantType = 0;
pub const DVLE_CONST_u8: DVLE_constantType = 1;
pub const DVLE_CONST_FLOAT24: DVLE_constantType = 2;
pub type DVLE_constantType = ::libc::c_uint;
pub const RESULT_POSITION: DVLE_outputAttribute_t = 0;
pub const RESULT_NORMALQUAT: DVLE_outputAttribute_t = 1;
pub const RESULT_COLOR: DVLE_outputAttribute_t = 2;
pub const RESULT_TEXCOORD0: DVLE_outputAttribute_t = 3;
pub const RESULT_TEXCOORD0W: DVLE_outputAttribute_t = 4;
pub const RESULT_TEXCOORD1: DVLE_outputAttribute_t = 5;
pub const RESULT_TEXCOORD2: DVLE_outputAttribute_t = 6;
pub const RESULT_VIEW: DVLE_outputAttribute_t = 8;
pub const RESULT_DUMMY: DVLE_outputAttribute_t = 9;
pub type DVLE_outputAttribute_t = ::libc::c_uint;
pub const GSH_POINT: DVLE_geoShaderMode = 0;
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
pub type DVLE_geoShaderMode = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    pub codeSize: u32_,
    pub codeData: *mut u32_,
    pub opdescSize: u32_,
    pub opcdescData: *mut u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_constEntry_s {
    pub type_: u16_,
    pub id: u16_,
    pub data: [u32_; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_outEntry_s {
    pub type_: u16_,
    pub regID: u16_,
    pub mask: u8_,
    pub unk: [u8_; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    pub symbolOffset: u32_,
    pub startReg: u16_,
    pub endReg: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    pub type_: DVLE_type,
    pub mergeOutmaps: bool,
    pub gshMode: DVLE_geoShaderMode,
    pub gshFixedVtxStart: u8_,
    pub gshVariableVtxNum: u8_,
    pub gshFixedVtxNum: u8_,
    pub dvlp: *mut DVLP_s,
    pub mainOffset: u32_,
    pub endmainOffset: u32_,
    pub constTableSize: u32_,
    pub constTableData: *mut DVLE_constEntry_s,
    pub outTableSize: u32_,
    pub outTableData: *mut DVLE_outEntry_s,
    pub uniformTableSize: u32_,
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    pub symbolTableData: *mut ::libc::c_char,
    pub outmapMask: u8_,
    pub outmapData: [u32_; 8usize],
    pub outmapMode: u32_,
    pub outmapClock: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    pub numDVLE: u32_,
    pub DVLP: DVLP_s,
    pub DVLE: *mut DVLE_s,
}
extern "C" {
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
extern "C" {
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
extern "C" {
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s, name: *const ::libc::c_char) -> s8;
}
extern "C" {
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float24Uniform_s {
    pub id: u32_,
    pub data: [u32_; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    pub dvle: *mut DVLE_s,
    pub boolUniforms: u16_,
    pub boolUniformMask: u16_,
    pub intUniforms: [u32_; 4usize],
    pub float24Uniforms: *mut float24Uniform_s,
    pub intUniformMask: u8_,
    pub numFloat24Uniforms: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    pub vertexShader: *mut shaderInstance_s,
    pub geometryShader: *mut shaderInstance_s,
    pub geoShaderInputPermutation: [u32_; 2usize],
    pub geoShaderInputStride: u8_,
}
extern "C" {
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
extern "C" {
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8_) -> Result;
}
extern "C" {
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64_,
    ) -> Result;
}
extern "C" {
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
extern "C" {
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
pub const NDSP_OUTPUT_MONO: ndspOutputMode = 0;
pub const NDSP_OUTPUT_STEREO: ndspOutputMode = 1;
pub const NDSP_OUTPUT_SURROUND: ndspOutputMode = 2;
pub type ndspOutputMode = ::libc::c_uint;
pub const NDSP_CLIP_NORMAL: ndspClippingMode = 0;
pub const NDSP_CLIP_SOFT: ndspClippingMode = 1;
pub type ndspClippingMode = ::libc::c_uint;
pub const NDSP_SPKPOS_SQUARE: ndspSpeakerPos = 0;
pub const NDSP_SPKPOS_WIDE: ndspSpeakerPos = 1;
pub const NDSP_SPKPOS_NUM: ndspSpeakerPos = 2;
pub type ndspSpeakerPos = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ndspAdpcmData {
    pub index: u16_,
    pub history0: s16,
    pub history1: s16,
}
pub type ndspWaveBuf = tag_ndspWaveBuf;
pub const NDSP_WBUF_FREE: ::libc::c_uint = 0;
pub const NDSP_WBUF_QUEUED: ::libc::c_uint = 1;
pub const NDSP_WBUF_PLAYING: ::libc::c_uint = 2;
pub const NDSP_WBUF_DONE: ::libc::c_uint = 3;
pub type _bindgen_ty_29 = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    pub nsamples: u32_,
    pub adpcm_data: *mut ndspAdpcmData,
    pub offset: u32_,
    pub looping: bool,
    pub status: u8_,
    pub sequence_id: u16_,
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    pub data_pcm8: *mut s8,
    pub data_pcm16: *mut s16,
    pub data_adpcm: *mut u8_,
    pub data_vaddr: *const ::libc::c_void,
}
pub type ndspCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
pub type ndspAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        nsamples: ::libc::c_int,
        samples: *mut *mut ::libc::c_void,
    ),
>;
extern "C" {
    pub fn ndspUseComponent(
        binary: *const ::libc::c_void,
        size: u32_,
        progMask: u16_,
        dataMask: u16_,
    );
}
extern "C" {
    pub fn ndspInit() -> Result;
}
extern "C" {
    pub fn ndspExit();
}
extern "C" {
    pub fn ndspGetDroppedFrames() -> u32_;
}
extern "C" {
    pub fn ndspGetFrameCount() -> u32_;
}
extern "C" {
    pub fn ndspSetMasterVol(volume: f32);
}
extern "C" {
    pub fn ndspGetMasterVol() -> f32;
}
extern "C" {
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
extern "C" {
    pub fn ndspGetOutputMode() -> ndspOutputMode;
}
extern "C" {
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
extern "C" {
    pub fn ndspGetClippingMode() -> ndspClippingMode;
}
extern "C" {
    pub fn ndspSetOutputCount(count: ::libc::c_int);
}
extern "C" {
    pub fn ndspGetOutputCount() -> ::libc::c_int;
}
extern "C" {
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut ::libc::c_void);
}
extern "C" {
    pub fn ndspSurroundSetDepth(depth: u16_);
}
extern "C" {
    pub fn ndspSurroundGetDepth() -> u16_;
}
extern "C" {
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
extern "C" {
    pub fn ndspSurroundGetPos() -> ndspSpeakerPos;
}
extern "C" {
    pub fn ndspSurroundSetRearRatio(ratio: u16_);
}
extern "C" {
    pub fn ndspSurroundGetRearRatio() -> u16_;
}
extern "C" {
    pub fn ndspAuxSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspAuxIsEnabled(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspAuxSetFrontBypass(id: ::libc::c_int, bypass: bool);
}
extern "C" {
    pub fn ndspAuxGetFrontBypass(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspAuxSetVolume(id: ::libc::c_int, volume: f32);
}
extern "C" {
    pub fn ndspAuxGetVolume(id: ::libc::c_int) -> f32;
}
extern "C" {
    pub fn ndspAuxSetCallback(
        id: ::libc::c_int,
        callback: ndspAuxCallback,
        data: *mut ::libc::c_void,
    );
}
pub const NDSP_ENCODING_PCM8: ::libc::c_uint = 0;
pub const NDSP_ENCODING_PCM16: ::libc::c_uint = 1;
pub const NDSP_ENCODING_ADPCM: ::libc::c_uint = 2;
pub type _bindgen_ty_30 = ::libc::c_uint;
pub const NDSP_FORMAT_MONO_PCM8: ::libc::c_uint = 1;
pub const NDSP_FORMAT_MONO_PCM16: ::libc::c_uint = 5;
pub const NDSP_FORMAT_MONO_ADPCM: ::libc::c_uint = 9;
pub const NDSP_FORMAT_STEREO_PCM8: ::libc::c_uint = 2;
pub const NDSP_FORMAT_STEREO_PCM16: ::libc::c_uint = 6;
pub const NDSP_FORMAT_PCM8: ::libc::c_uint = 1;
pub const NDSP_FORMAT_PCM16: ::libc::c_uint = 5;
pub const NDSP_FORMAT_ADPCM: ::libc::c_uint = 9;
pub const NDSP_FRONT_BYPASS: ::libc::c_uint = 16;
pub const NDSP_3D_SURROUND_PREPROCESSED: ::libc::c_uint = 64;
pub type _bindgen_ty_31 = ::libc::c_uint;
pub const NDSP_INTERP_POLYPHASE: ndspInterpType = 0;
pub const NDSP_INTERP_LINEAR: ndspInterpType = 1;
pub const NDSP_INTERP_NONE: ndspInterpType = 2;
pub type ndspInterpType = ::libc::c_uint;
extern "C" {
    pub fn ndspChnReset(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnInitParams(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnIsPlaying(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnGetSamplePos(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn ndspChnGetWaveBufSeq(id: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn ndspChnIsPaused(id: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnSetPaused(id: ::libc::c_int, paused: bool);
}
extern "C" {
    pub fn ndspChnSetFormat(id: ::libc::c_int, format: u16_);
}
extern "C" {
    pub fn ndspChnGetFormat(id: ::libc::c_int) -> u16_;
}
extern "C" {
    pub fn ndspChnSetInterp(id: ::libc::c_int, type_: ndspInterpType);
}
extern "C" {
    pub fn ndspChnGetInterp(id: ::libc::c_int) -> ndspInterpType;
}
extern "C" {
    pub fn ndspChnSetRate(id: ::libc::c_int, rate: f32);
}
extern "C" {
    pub fn ndspChnGetRate(id: ::libc::c_int) -> f32;
}
extern "C" {
    pub fn ndspChnSetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    pub fn ndspChnGetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    pub fn ndspChnSetAdpcmCoefs(id: ::libc::c_int, coefs: *mut u16_);
}
extern "C" {
    pub fn ndspChnWaveBufClear(id: ::libc::c_int);
}
extern "C" {
    pub fn ndspChnWaveBufAdd(id: ::libc::c_int, buf: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspChnIirMonoSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        b0: f32,
    ) -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    ) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(
        id: ::libc::c_int,
        f0: f32,
        Q: f32,
        gain: f32,
    ) -> bool;
}
pub const SWKBD_TYPE_NORMAL: SwkbdType = 0;
pub const SWKBD_TYPE_QWERTY: SwkbdType = 1;
pub const SWKBD_TYPE_NUMPAD: SwkbdType = 2;
pub const SWKBD_TYPE_WESTERN: SwkbdType = 3;
pub type SwkbdType = ::libc::c_uint;
pub const SWKBD_ANYTHING: SwkbdValidInput = 0;
pub const SWKBD_NOTEMPTY: SwkbdValidInput = 1;
pub const SWKBD_NOTEMPTY_NOTBLANK: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK: SwkbdValidInput = 3;
pub const SWKBD_FIXEDLEN: SwkbdValidInput = 4;
pub type SwkbdValidInput = ::libc::c_uint;
pub const SWKBD_BUTTON_LEFT: SwkbdButton = 0;
pub const SWKBD_BUTTON_MIDDLE: SwkbdButton = 1;
pub const SWKBD_BUTTON_RIGHT: SwkbdButton = 2;
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = 2;
pub const SWKBD_BUTTON_NONE: SwkbdButton = 3;
pub type SwkbdButton = ::libc::c_uint;
pub const SWKBD_PASSWORD_NONE: SwkbdPasswordMode = 0;
pub const SWKBD_PASSWORD_HIDE: SwkbdPasswordMode = 1;
pub const SWKBD_PASSWORD_HIDE_DELAY: SwkbdPasswordMode = 2;
pub type SwkbdPasswordMode = ::libc::c_uint;
pub const SWKBD_FILTER_DIGITS: ::libc::c_uint = 1;
pub const SWKBD_FILTER_AT: ::libc::c_uint = 2;
pub const SWKBD_FILTER_PERCENT: ::libc::c_uint = 4;
pub const SWKBD_FILTER_BACKSLASH: ::libc::c_uint = 8;
pub const SWKBD_FILTER_PROFANITY: ::libc::c_uint = 16;
pub const SWKBD_FILTER_CALLBACK: ::libc::c_uint = 32;
pub type _bindgen_ty_32 = ::libc::c_uint;
pub const SWKBD_PARENTAL: ::libc::c_uint = 1;
pub const SWKBD_DARKEN_TOP_SCREEN: ::libc::c_uint = 2;
pub const SWKBD_PREDICTIVE_INPUT: ::libc::c_uint = 4;
pub const SWKBD_MULTILINE: ::libc::c_uint = 8;
pub const SWKBD_FIXED_WIDTH: ::libc::c_uint = 16;
pub const SWKBD_ALLOW_HOME: ::libc::c_uint = 32;
pub const SWKBD_ALLOW_RESET: ::libc::c_uint = 64;
pub const SWKBD_ALLOW_POWER: ::libc::c_uint = 128;
pub const SWKBD_DEFAULT_QWERTY: ::libc::c_uint = 512;
pub type _bindgen_ty_33 = ::libc::c_uint;
pub const SWKBD_CALLBACK_OK: SwkbdCallbackResult = 0;
pub const SWKBD_CALLBACK_CLOSE: SwkbdCallbackResult = 1;
pub const SWKBD_CALLBACK_CONTINUE: SwkbdCallbackResult = 2;
pub type SwkbdCallbackResult = ::libc::c_uint;
pub const SWKBD_NONE: SwkbdResult = -1;
pub const SWKBD_INVALID_INPUT: SwkbdResult = -2;
pub const SWKBD_OUTOFMEM: SwkbdResult = -3;
pub const SWKBD_D0_CLICK: SwkbdResult = 0;
pub const SWKBD_D1_CLICK0: SwkbdResult = 1;
pub const SWKBD_D1_CLICK1: SwkbdResult = 2;
pub const SWKBD_D2_CLICK0: SwkbdResult = 3;
pub const SWKBD_D2_CLICK1: SwkbdResult = 4;
pub const SWKBD_D2_CLICK2: SwkbdResult = 5;
pub const SWKBD_HOMEPRESSED: SwkbdResult = 10;
pub const SWKBD_RESETPRESSED: SwkbdResult = 11;
pub const SWKBD_POWERPRESSED: SwkbdResult = 12;
pub const SWKBD_PARENTAL_OK: SwkbdResult = 20;
pub const SWKBD_PARENTAL_FAIL: SwkbdResult = 21;
pub const SWKBD_BANNED_INPUT: SwkbdResult = 30;
pub type SwkbdResult = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdDictWord {
    pub reading: [u16_; 41usize],
    pub word: [u16_; 41usize],
    pub language: u8_,
    pub all_languages: bool,
}
pub type SwkbdCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        ppMessage: *mut *const ::libc::c_char,
        text: *const ::libc::c_char,
        textlen: size_t,
    ) -> SwkbdCallbackResult,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdStatusData {
    pub data: [u32_; 17usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdLearningData {
    pub data: [u32_; 10523usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdExtra {
    pub initial_text: *const ::libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwkbdState {
    pub type_: ::libc::c_int,
    pub num_buttons_m1: ::libc::c_int,
    pub valid_input: ::libc::c_int,
    pub password_mode: ::libc::c_int,
    pub is_parental_screen: ::libc::c_int,
    pub darken_top_screen: ::libc::c_int,
    pub filter_flags: u32_,
    pub save_state_flags: u32_,
    pub max_text_len: u16_,
    pub dict_word_count: u16_,
    pub max_digits: u16_,
    pub button_text: [[u16_; 17usize]; 3usize],
    pub numpad_keys: [u16_; 2usize],
    pub hint_text: [u16_; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16_,
    pub initial_text_offset: ::libc::c_int,
    pub dict_offset: ::libc::c_int,
    pub initial_status_offset: ::libc::c_int,
    pub initial_learning_offset: ::libc::c_int,
    pub shared_memory_size: size_t,
    pub version: u32_,
    pub result: SwkbdResult,
    pub status_offset: ::libc::c_int,
    pub learning_offset: ::libc::c_int,
    pub text_offset: ::libc::c_int,
    pub text_length: u16_,
    pub callback_result: ::libc::c_int,
    pub callback_msg: [u16_; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SwkbdState__bindgen_ty_1 {
    pub reserved: [u8_; 171usize],
    pub extra: SwkbdExtra,
}
extern "C" {
    pub fn swkbdInit(
        swkbd: *mut SwkbdState,
        type_: SwkbdType,
        numButtons: ::libc::c_int,
        maxTextLength: ::libc::c_int,
    );
}
extern "C" {
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32_);
}
extern "C" {
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    pub fn swkbdSetButton(
        swkbd: *mut SwkbdState,
        button: SwkbdButton,
        text: *const ::libc::c_char,
        submit: bool,
    );
}
extern "C" {
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    pub fn swkbdSetDictWord(
        word: *mut SwkbdDictWord,
        reading: *const ::libc::c_char,
        text: *const ::libc::c_char,
    );
}
extern "C" {
    pub fn swkbdSetDictionary(
        swkbd: *mut SwkbdState,
        dict: *const SwkbdDictWord,
        wordCount: ::libc::c_int,
    );
}
extern "C" {
    pub fn swkbdSetStatusData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdStatusData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    pub fn swkbdSetLearningData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdLearningData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    pub fn swkbdSetFilterCallback(
        swkbd: *mut SwkbdState,
        callback: SwkbdCallbackFn,
        user: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn swkbdInputText(
        swkbd: *mut SwkbdState,
        buf: *mut ::libc::c_char,
        bufsize: size_t,
    ) -> SwkbdButton;
}
pub const ERROR_LANGUAGE_FLAG: ::libc::c_uint = 256;
pub const ERROR_WORD_WRAP_FLAG: ::libc::c_uint = 512;
pub type _bindgen_ty_34 = ::libc::c_uint;
pub const ERROR_CODE: errorType = 0;
pub const ERROR_TEXT: errorType = 1;
pub const ERROR_EULA: errorType = 2;
pub const ERROR_TYPE_EULA_FIRST_BOOT: errorType = 3;
pub const ERROR_TYPE_EULA_DRAW_ONLY: errorType = 4;
pub const ERROR_TYPE_AGREE: errorType = 5;
pub const ERROR_CODE_LANGUAGE: errorType = 256;
pub const ERROR_TEXT_LANGUAGE: errorType = 257;
pub const ERROR_EULA_LANGUAGE: errorType = 258;
pub const ERROR_TEXT_WORD_WRAP: errorType = 513;
pub const ERROR_TEXT_LANGUAGE_WORD_WRAP: errorType = 769;
pub type errorType = ::libc::c_uint;
pub const ERROR_NORMAL: errorScreenFlag = 0;
pub const ERROR_STEREO: errorScreenFlag = 1;
pub type errorScreenFlag = ::libc::c_uint;
pub const ERROR_UNKNOWN: errorReturnCode = -1;
pub const ERROR_NONE: errorReturnCode = 0;
pub const ERROR_SUCCESS: errorReturnCode = 1;
pub const ERROR_NOT_SUPPORTED: errorReturnCode = 2;
pub const ERROR_HOME_BUTTON: errorReturnCode = 10;
pub const ERROR_SOFTWARE_RESET: errorReturnCode = 11;
pub const ERROR_POWER_BUTTON: errorReturnCode = 12;
pub type errorReturnCode = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: ::libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16_,
    pub Text: [u16_; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16_,
}
extern "C" {
    pub fn errorInit(err: *mut errorConf, type_: errorType, lang: CFG_Language);
}
extern "C" {
    pub fn errorCode(err: *mut errorConf, error: ::libc::c_int);
}
extern "C" {
    pub fn errorText(err: *mut errorConf, text: *const ::libc::c_char);
}
extern "C" {
    pub fn errorDisp(err: *mut errorConf);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiiSelectorConf {
    pub enable_cancel_button: u8_,
    pub enable_selecting_guests: u8_,
    pub show_on_top_screen: u8_,
    pub _unk0x3: [u8_; 5usize],
    pub title: [u16_; 64usize],
    pub _unk0x88: [u8_; 4usize],
    pub show_guest_page: u8_,
    pub _unk0x8D: [u8_; 3usize],
    pub initial_index: u32_,
    pub mii_guest_whitelist: [u8_; 6usize],
    pub mii_whitelist: [u8_; 100usize],
    pub _unk0xFE: u16_,
    pub magic: u32_,
}
#[repr(C)]
pub struct MiiSelectorReturn {
    pub no_mii_selected: u32_,
    pub guest_mii_was_selected: u32_,
    pub guest_mii_index: u32_,
    pub mii: MiiData,
    pub _pad0x68: u16_,
    pub checksum: u16_,
    pub guest_mii_name: [u16_; 12usize],
}
pub const MIISELECTOR_CANCEL: ::libc::c_uint = 1;
pub const MIISELECTOR_GUESTS: ::libc::c_uint = 2;
pub const MIISELECTOR_TOP: ::libc::c_uint = 4;
pub const MIISELECTOR_GUESTSTART: ::libc::c_uint = 8;
pub type _bindgen_ty_35 = ::libc::c_uint;
extern "C" {
    pub fn miiSelectorInit(conf: *mut MiiSelectorConf);
}
extern "C" {
    pub fn miiSelectorLaunch(conf: *const MiiSelectorConf, returnbuf: *mut MiiSelectorReturn);
}
extern "C" {
    pub fn miiSelectorSetTitle(conf: *mut MiiSelectorConf, text: *const ::libc::c_char);
}
extern "C" {
    pub fn miiSelectorSetOptions(conf: *mut MiiSelectorConf, options: u32_);
}
extern "C" {
    pub fn miiSelectorWhitelistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    pub fn miiSelectorBlacklistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    pub fn miiSelectorWhitelistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    pub fn miiSelectorBlacklistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    pub fn miiSelectorReturnGetName(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: size_t,
    );
}
extern "C" {
    pub fn miiSelectorReturnGetAuthor(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: size_t,
    );
}
extern "C" {
    pub fn miiSelectorChecksumIsValid(returnbuf: *const MiiSelectorReturn) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_dir_t {
    pub magic: u32_,
    pub fd: Handle,
    pub index: ssize_t,
    pub size: size_t,
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
extern "C" {
    pub fn archiveMountSdmc() -> Result;
}
extern "C" {
    pub fn archiveMount(
        archiveID: FS_ArchiveID,
        archivePath: FS_Path,
        deviceName: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn archiveCommitSaveData(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn archiveUnmount(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn archiveUnmountAll() -> Result;
}
extern "C" {
    pub fn archive_getmtime(name: *const ::libc::c_char, mtime: *mut u64_) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct romfs_header {
    pub headerSize: u32_,
    pub dirHashTableOff: u32_,
    pub dirHashTableSize: u32_,
    pub dirTableOff: u32_,
    pub dirTableSize: u32_,
    pub fileHashTableOff: u32_,
    pub fileHashTableSize: u32_,
    pub fileTableOff: u32_,
    pub fileTableSize: u32_,
    pub fileDataOff: u32_,
}
#[repr(C)]
#[derive(Debug)]
pub struct romfs_dir {
    pub parent: u32_,
    pub sibling: u32_,
    pub childDir: u32_,
    pub childFile: u32_,
    pub nextHash: u32_,
    pub nameLen: u32_,
    pub name: __IncompleteArrayField<u16_>,
}
#[repr(C)]
#[derive(Debug)]
pub struct romfs_file {
    pub parent: u32_,
    pub sibling: u32_,
    pub dataOff: u64_,
    pub dataSize: u64_,
    pub nextHash: u32_,
    pub nameLen: u32_,
    pub name: __IncompleteArrayField<u16_>,
}
extern "C" {
    pub fn romfsMountSelf(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn romfsMountFromFile(fd: Handle, offset: u32_, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn romfsMountFromCurrentProcess(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    pub fn romfsMountFromTitle(
        tid: u64_,
        mediatype: FS_MediaType,
        name: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    pub fn romfsUnmount(name: *const ::libc::c_char) -> Result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct charWidthInfo_s {
    pub left: s8,
    pub glyphWidth: u8_,
    pub charWidth: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TGLP_s {
    pub cellWidth: u8_,
    pub cellHeight: u8_,
    pub baselinePos: u8_,
    pub maxCharWidth: u8_,
    pub sheetSize: u32_,
    pub nSheets: u16_,
    pub sheetFmt: u16_,
    pub nRows: u16_,
    pub nLines: u16_,
    pub sheetWidth: u16_,
    pub sheetHeight: u16_,
    pub sheetData: *mut u8_,
}
pub type CWDH_s = tag_CWDH_s;
#[repr(C)]
#[derive(Debug)]
pub struct tag_CWDH_s {
    pub startIndex: u16_,
    pub endIndex: u16_,
    pub next: *mut CWDH_s,
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
pub const CMAP_TYPE_DIRECT: ::libc::c_uint = 0;
pub const CMAP_TYPE_TABLE: ::libc::c_uint = 1;
pub const CMAP_TYPE_SCAN: ::libc::c_uint = 2;
pub type _bindgen_ty_36 = ::libc::c_uint;
pub type CMAP_s = tag_CMAP_s;
#[repr(C)]
pub struct tag_CMAP_s {
    pub codeBegin: u16_,
    pub codeEnd: u16_,
    pub mappingMethod: u16_,
    pub reserved: u16_,
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    pub indexOffset: __BindgenUnionField<u16_>,
    pub indexTable: __BindgenUnionField<[u16_; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[repr(C)]
#[derive(Debug)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    pub nScanEntries: u16_,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub code: u16_,
    pub glyphIndex: u16_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FINF_s {
    pub signature: u32_,
    pub sectionSize: u32_,
    pub fontType: u8_,
    pub lineFeed: u8_,
    pub alterCharIndex: u16_,
    pub defaultWidth: charWidthInfo_s,
    pub encoding: u8_,
    pub tglp: *mut TGLP_s,
    pub cwdh: *mut CWDH_s,
    pub cmap: *mut CMAP_s,
    pub height: u8_,
    pub width: u8_,
    pub ascent: u8_,
    pub padding: u8_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFNT_s {
    pub signature: u32_,
    pub endianness: u16_,
    pub headerSize: u16_,
    pub version: u32_,
    pub fileSize: u32_,
    pub nBlocks: u32_,
    pub finf: FINF_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s {
    pub sheetIndex: ::libc::c_int,
    pub xOffset: f32,
    pub xAdvance: f32,
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
pub const GLYPH_POS_CALC_VTXCOORD: ::libc::c_uint = 1;
pub const GLYPH_POS_AT_BASELINE: ::libc::c_uint = 2;
pub const GLYPH_POS_Y_POINTS_UP: ::libc::c_uint = 4;
pub type _bindgen_ty_37 = ::libc::c_uint;
extern "C" {
    pub fn fontEnsureMapped() -> Result;
}
extern "C" {
    pub fn fontFixPointers(font: *mut CFNT_s);
}
extern "C" {
    pub fn fontGlyphIndexFromCodePoint(font: *mut CFNT_s, codePoint: u32_) -> ::libc::c_int;
}
extern "C" {
    pub fn fontGetCharWidthInfo(
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    pub fn fontCalcGlyphPos(
        out: *mut fontGlyphPos_s,
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    pub fn gdbHioDevInit() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevExit();
}
extern "C" {
    pub fn gdbHioDevGetStdin() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStdout() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStderr() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevRedirectStdStreams(in_: bool, out: bool, err: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGettimeofday(tv: *mut timeval, tz: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevIsatty(fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevSystem(command: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub static mut __3dslink_host: in_addr;
}
extern "C" {
    pub fn link3dsConnectToHost(redirStdout: bool, redirStderr: bool) -> ::libc::c_int;
}
pub type C3D_IVec = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    pub c: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    pub w: f32,
    pub z: f32,
    pub y: f32,
    pub x: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    pub r: f32,
    pub k: f32,
    pub j: f32,
    pub i: f32,
}
pub type C3D_FQuat = C3D_FVec;
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    pub r: [C3D_FVec; 4usize],
    pub m: [f32; 16usize],
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::libc::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn finitel(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn isinff(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn isnanf(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn isinf(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn isnan(arg1: f64) -> ::libc::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn __isinfd(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn __isnanf(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn __isnand(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn __signbitf(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn __signbitd(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const ::libc::c_char) -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::libc::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::libc::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::libc::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::libc::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::libc::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::libc::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::libc::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::libc::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::libc::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::libc::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::libc::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::libc::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::libc::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const ::libc::c_char) -> f32;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::libc::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::libc::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::libc::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::libc::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::libc::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::libc::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::libc::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::libc::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::libc::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::libc::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut ::libc::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut ::libc::c_int) -> f32;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut ::libc::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::libc::c_void, arg2: *mut ::libc::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut ::libc::c_void, arg2: ::libc::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::libc::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn fls(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn index(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::libc::c_void,
        arg2: ::libc::c_int,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::libc::c_void,
        arg2: ::libc::c_int,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::libc::c_char) -> ::libc::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const ::libc::c_char, arg2: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_uint;
}
extern "C" {
    pub fn strstr(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::libc::c_int, arg2: locale_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::libc::c_void,
        arg2: *const ::libc::c_void,
        arg3: ::libc::c_int,
        arg4: ::libc::c_uint,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::libc::c_char, arg2: ::libc::c_uint) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: size_t,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strerror_r(
        arg1: ::libc::c_int,
        arg2: *mut ::libc::c_char,
        arg3: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_uint,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const ::libc::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: size_t,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
extern "C" {
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
extern "C" {
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
extern "C" {
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
extern "C" {
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
extern "C" {
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
extern "C" {
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
extern "C" {
    pub fn Quat_Multiply(lhs: C3D_FQuat, rhs: C3D_FQuat) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_Pow(q: C3D_FQuat, p: f32) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_CrossFVec3(q: C3D_FQuat, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    pub fn Quat_Rotate(q: C3D_FQuat, axis: C3D_FVec, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_RotateX(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_RotateY(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_RotateZ(q: C3D_FQuat, r: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_FromMtx(m: *const C3D_Mtx) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_FromPitchYawRoll(pitch: f32, yaw: f32, roll: f32, bRightSide: bool) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_LookAt(
        source: C3D_FVec,
        target: C3D_FVec,
        forwardVector: C3D_FVec,
        upVector: C3D_FVec,
    ) -> C3D_FQuat;
}
extern "C" {
    pub fn Quat_FromAxisAngle(axis: C3D_FVec, angle: f32) -> C3D_FQuat;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
extern "C" {
    pub fn MtxStack_Init(stk: *mut C3D_MtxStack);
}
extern "C" {
    pub fn MtxStack_Bind(
        stk: *mut C3D_MtxStack,
        unifType: GPU_SHADER_TYPE,
        unifPos: ::libc::c_int,
        unifLen: ::libc::c_int,
    );
}
extern "C" {
    pub fn MtxStack_Push(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
extern "C" {
    pub fn MtxStack_Pop(stk: *mut C3D_MtxStack) -> *mut C3D_Mtx;
}
extern "C" {
    pub fn MtxStack_Update(stk: *mut C3D_MtxStack);
}
extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: ::libc::c_uint = 0;
pub const C3D_UNSIGNED_SHORT: ::libc::c_uint = 1;
pub type _bindgen_ty_38 = ::libc::c_uint;
extern "C" {
    pub fn C3D_Init(cmdBufSize: size_t) -> bool;
}
extern "C" {
    pub fn C3D_Fini();
}
extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
extern "C" {
    pub fn C3D_ImmDrawEnd();
}
extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uint;
extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> size_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: size_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: size_t) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u32 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_ProcTex_U: ::libc::c_uint = 1;
pub const C3D_ProcTex_V: ::libc::c_uint = 2;
pub const C3D_ProcTex_UV: ::libc::c_uint = 3;
pub type _bindgen_ty_39 = ::libc::c_uint;
extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
extern "C" {
    pub fn ProcTexLut_FromArray(lut: *mut C3D_ProcTexLut, in_: *const f32);
}
extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
extern "C" {
    pub fn ProcTexColorLut_Write(
        out: *mut C3D_ProcTexColorLut,
        in_: *const u32_,
        offset: ::libc::c_int,
        length: ::libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
extern "C" {
    pub fn LightLut_FromArray(lut: *mut C3D_LightLut, data: *mut f32);
}
extern "C" {
    pub fn LightLut_FromFunc(
        lut: *mut C3D_LightLut,
        func: C3D_LightLutFunc,
        param: f32,
        negative: bool,
    );
}
extern "C" {
    pub fn LightLutDA_Create(
        lut: *mut C3D_LightLutDA,
        func: C3D_LightLutFuncDA,
        from: f32,
        to: f32,
        arg0: f32,
        arg1: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
pub const C3DF_LightEnv_Dirty: ::libc::c_uint = 1;
pub const C3DF_LightEnv_MtlDirty: ::libc::c_uint = 2;
pub const C3DF_LightEnv_LCDirty: ::libc::c_uint = 4;
pub type _bindgen_ty_40 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
pub const GPU_SHADOW_PRIMARY: ::libc::c_uint = 65536;
pub const GPU_SHADOW_SECONDARY: ::libc::c_uint = 131072;
pub const GPU_INVERT_SHADOW: ::libc::c_uint = 262144;
pub const GPU_SHADOW_ALPHA: ::libc::c_uint = 524288;
pub type _bindgen_ty_41 = ::libc::c_uint;
extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
pub const C3DF_Light_Enabled: ::libc::c_uint = 1;
pub const C3DF_Light_Dirty: ::libc::c_uint = 2;
pub const C3DF_Light_MatDirty: ::libc::c_uint = 4;
pub const C3DF_Light_SPDirty: ::libc::c_uint = 16384;
pub const C3DF_Light_DADirty: ::libc::c_uint = 32768;
pub type _bindgen_ty_42 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
extern "C" {
    pub fn FogLut_FromArray(lut: *mut C3D_FogLut, data: *const f32);
}
extern "C" {
    pub fn FogLut_Exp(lut: *mut C3D_FogLut, density: f32, gradient: f32, near: f32, far: f32);
}
extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
extern "C" {
    pub fn GasLut_FromArray(lut: *mut C3D_GasLut, data: *const u32_);
}
extern "C" {
    pub fn C3D_GasBeginAcc();
}
extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uint;
extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub const C3D_FRAME_SYNCDRAW: ::libc::c_uint = 1;
pub const C3D_FRAME_NONBLOCK: ::libc::c_uint = 2;
pub type _bindgen_ty_43 = ::libc::c_uint;
extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
extern "C" {
    pub fn C3D_FrameSync();
}
extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
}
extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: size_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::libc::c_char, arg3: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::libc::c_char, arg2: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::libc::c_char,
        arg2: ::libc::c_int,
        arg3: *mut FILE,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::libc::c_char, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar() -> ::libc::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn putc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::libc::c_void,
        _size: ::libc::c_uint,
        _n: ::libc::c_uint,
        arg2: *mut FILE,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::libc::c_void,
        _size: ::libc::c_uint,
        _n: ::libc::c_uint,
        arg2: *mut FILE,
    ) -> ::libc::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::libc::c_long, arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::libc::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::libc::c_char, _type: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn rename(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::libc::c_char,
        arg2: ::libc::c_uint,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::libc::c_char,
        arg2: ::libc::c_uint,
        arg3: *const ::libc::c_char,
        arg4: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::libc::c_char, arg3: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::libc::c_char, arg2: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::libc::c_char,
        arg2: *mut size_t,
        arg3: *const ::libc::c_char,
        ...
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::libc::c_char,
        arg2: *mut size_t,
        arg3: *const ::libc::c_char,
        ...
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn diprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut ::libc::c_char, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::libc::c_char,
        arg2: size_t,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::libc::c_char,
        arg2: *mut size_t,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::libc::c_char,
        arg2: *mut size_t,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const ::libc::c_char, arg2: __gnuc_va_list) -> ::libc::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const ::libc::c_char, arg2: __gnuc_va_list) -> ::libc::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::libc::c_char,
        arg2: size_t,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::libc::c_int, arg2: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::libc::c_char, arg3: ::libc::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putw(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::libc::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::libc::c_int, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::libc::c_void,
        arg2: size_t,
        arg3: *const ::libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::libc::c_int,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *mut size_t,
        arg4: *const ::libc::c_char,
        ...
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *mut size_t,
        arg4: *const ::libc::c_char,
        ...
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::libc::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: *mut FILE,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: ::libc::c_int,
        arg4: *mut FILE,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_void,
        arg3: size_t,
        arg4: *const ::libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *mut FILE,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *mut FILE,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *mut FILE,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::libc::c_long,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::libc::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::libc::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::libc::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *mut FILE,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::libc::c_char,
        _new: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: size_t,
        arg4: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: size_t,
        arg4: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        ...
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *mut size_t,
        arg4: *const ::libc::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *mut size_t,
        arg4: *const ::libc::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::libc::c_int,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: size_t,
        arg4: *const ::libc::c_char,
        arg5: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: size_t,
        arg4: *const ::libc::c_char,
        arg5: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::libc::c_char,
        arg3: *const ::libc::c_char,
        arg4: __gnuc_va_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut size_t,
        arg3: ::libc::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut ::libc::c_char, arg2: *mut size_t, arg3: *mut FILE)
        -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::libc::c_int, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::libc::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::libc::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __buf: *mut ::libc::c_char,
                __n: ::libc::c_int,
            ) -> ::libc::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __buf: *const ::libc::c_char,
                __n: ::libc::c_int,
            ) -> ::libc::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __off: fpos_t,
                __whence: ::libc::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::libc::c_void) -> ::libc::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::libc::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __buf: *mut ::libc::c_char,
                __n: ::libc::c_int,
            ) -> ::libc::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __buf: *const ::libc::c_char,
                __n: ::libc::c_int,
            ) -> ::libc::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::libc::c_void,
                __off: fpos_t,
                __whence: ::libc::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::libc::c_void) -> ::libc::c_int,
        >,
    ) -> *mut FILE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_SubTexture {
    pub width: u16_,
    pub height: u16_,
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tex3DS_Texture_s {
    _unused: [u8; 0],
}
pub type Tex3DS_Texture = *mut Tex3DS_Texture_s;
extern "C" {
    pub fn Tex3DS_TextureImport(
        input: *const ::libc::c_void,
        insize: size_t,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    pub fn Tex3DS_TextureImportCallback(
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
    ) -> Tex3DS_Texture;
}
extern "C" {
    pub fn Tex3DS_TextureImportFD(
        fd: ::libc::c_int,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    pub fn Tex3DS_TextureImportStdio(
        fp: *mut FILE,
        tex: *mut C3D_Tex,
        texcube: *mut C3D_TexCube,
        vram: bool,
    ) -> Tex3DS_Texture;
}
extern "C" {
    pub fn Tex3DS_GetNumSubTextures(texture: Tex3DS_Texture) -> size_t;
}
extern "C" {
    pub fn Tex3DS_GetSubTexture(texture: Tex3DS_Texture, index: size_t)
        -> *const Tex3DS_SubTexture;
}
extern "C" {
    pub fn Tex3DS_TextureFree(texture: Tex3DS_Texture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams {
    pub pos: C2D_DrawParams__bindgen_ty_1,
    pub center: C2D_DrawParams__bindgen_ty_2,
    pub depth: f32,
    pub angle: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_2 {
    pub x: f32,
    pub y: f32,
}
pub const C2D_TintSolid: C2D_TintMode = 0;
pub const C2D_TintMult: C2D_TintMode = 1;
pub const C2D_TintLuma: C2D_TintMode = 2;
pub type C2D_TintMode = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Tint {
    pub color: u32_,
    pub blend: f32,
}
pub const C2D_TopLeft: C2D_Corner = 0;
pub const C2D_TopRight: C2D_Corner = 1;
pub const C2D_BotLeft: C2D_Corner = 2;
pub const C2D_BotRight: C2D_Corner = 3;
pub type C2D_Corner = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Image {
    pub tex: *mut C3D_Tex,
    pub subtex: *const Tex3DS_SubTexture,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_ImageTint {
    pub corners: [C2D_Tint; 4usize],
}
extern "C" {
    pub fn C2D_Init(maxObjects: size_t) -> bool;
}
extern "C" {
    pub fn C2D_Fini();
}
extern "C" {
    pub fn C2D_Prepare();
}
extern "C" {
    pub fn C2D_Flush();
}
extern "C" {
    pub fn C2D_SceneSize(width: u32_, height: u32_, tilt: bool);
}
extern "C" {
    pub fn C2D_ViewReset();
}
extern "C" {
    pub fn C2D_ViewSave(matrix: *mut C3D_Mtx);
}
extern "C" {
    pub fn C2D_ViewRestore(matrix: *const C3D_Mtx);
}
extern "C" {
    pub fn C2D_ViewTranslate(x: f32, y: f32);
}
extern "C" {
    pub fn C2D_ViewRotate(rotation: f32);
}
extern "C" {
    pub fn C2D_ViewShear(x: f32, y: f32);
}
extern "C" {
    pub fn C2D_ViewScale(x: f32, y: f32);
}
extern "C" {
    pub fn C2D_CreateScreenTarget(screen: gfxScreen_t, side: gfx3dSide_t) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C2D_TargetClear(target: *mut C3D_RenderTarget, color: u32_);
}
extern "C" {
    pub fn C2D_Fade(color: u32_);
}
extern "C" {
    pub fn C2D_SetTintMode(mode: C2D_TintMode);
}
extern "C" {
    pub fn C2D_DrawImage(
        img: C2D_Image,
        params: *const C2D_DrawParams,
        tint: *const C2D_ImageTint,
    ) -> bool;
}
extern "C" {
    pub fn C2D_DrawTriangle(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        x2: f32,
        y2: f32,
        clr2: u32_,
        depth: f32,
    ) -> bool;
}
extern "C" {
    pub fn C2D_DrawLine(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        thickness: f32,
        depth: f32,
    ) -> bool;
}
extern "C" {
    pub fn C2D_DrawRectangle(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
extern "C" {
    pub fn C2D_DrawEllipse(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_SpriteSheet_s {
    _unused: [u8; 0],
}
pub type C2D_SpriteSheet = *mut C2D_SpriteSheet_s;
extern "C" {
    pub fn C2D_SpriteSheetLoad(filename: *const ::libc::c_char) -> C2D_SpriteSheet;
}
extern "C" {
    pub fn C2D_SpriteSheetLoadFromMem(data: *const ::libc::c_void, size: size_t)
        -> C2D_SpriteSheet;
}
extern "C" {
    pub fn C2D_SpriteSheetFromFD(fd: ::libc::c_int) -> C2D_SpriteSheet;
}
extern "C" {
    pub fn C2D_SpriteSheetLoadFromHandle(f: *mut FILE) -> C2D_SpriteSheet;
}
extern "C" {
    pub fn C2D_SpriteSheetFree(sheet: C2D_SpriteSheet);
}
extern "C" {
    pub fn C2D_SpriteSheetCount(sheet: C2D_SpriteSheet) -> size_t;
}
extern "C" {
    pub fn C2D_SpriteSheetGetImage(sheet: C2D_SpriteSheet, index: size_t) -> C2D_Image;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Sprite {
    pub image: C2D_Image,
    pub params: C2D_DrawParams,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Font_s {
    _unused: [u8; 0],
}
pub type C2D_Font = *mut C2D_Font_s;
extern "C" {
    pub fn C2D_FontLoad(filename: *const ::libc::c_char) -> C2D_Font;
}
extern "C" {
    pub fn C2D_FontLoadFromMem(data: *const ::libc::c_void, size: size_t) -> C2D_Font;
}
extern "C" {
    pub fn C2D_FontLoadFromFD(fd: ::libc::c_int) -> C2D_Font;
}
extern "C" {
    pub fn C2D_FontLoadFromHandle(f: *mut FILE) -> C2D_Font;
}
extern "C" {
    pub fn C2D_FontLoadSystem(region: CFG_Region) -> C2D_Font;
}
extern "C" {
    pub fn C2D_FontFree(font: C2D_Font);
}
extern "C" {
    pub fn C2D_FontSetFilter(
        font: C2D_Font,
        magFilter: GPU_TEXTURE_FILTER_PARAM,
        minFilter: GPU_TEXTURE_FILTER_PARAM,
    );
}
extern "C" {
    pub fn C2D_FontGlyphIndexFromCodePoint(font: C2D_Font, codepoint: u32_) -> ::libc::c_int;
}
extern "C" {
    pub fn C2D_FontGetCharWidthInfo(
        font: C2D_Font,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    pub fn C2D_FontCalcGlyphPos(
        font: C2D_Font,
        out: *mut fontGlyphPos_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    pub fn C2D_FontGetInfo(font: C2D_Font) -> *mut FINF_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_TextBuf_s {
    _unused: [u8; 0],
}
pub type C2D_TextBuf = *mut C2D_TextBuf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Text {
    pub buf: C2D_TextBuf,
    pub begin: size_t,
    pub end: size_t,
    pub width: f32,
    pub lines: u32_,
    pub words: u32_,
    pub font: C2D_Font,
}
pub const C2D_AtBaseline: ::libc::c_uint = 1;
pub const C2D_WithColor: ::libc::c_uint = 2;
pub const C2D_AlignLeft: ::libc::c_uint = 0;
pub const C2D_AlignRight: ::libc::c_uint = 4;
pub const C2D_AlignCenter: ::libc::c_uint = 8;
pub const C2D_AlignJustified: ::libc::c_uint = 12;
pub const C2D_AlignMask: ::libc::c_uint = 12;
pub const C2D_WordWrap: ::libc::c_uint = 16;
pub type _bindgen_ty_44 = ::libc::c_uint;
extern "C" {
    pub fn C2D_TextBufNew(maxGlyphs: size_t) -> C2D_TextBuf;
}
extern "C" {
    pub fn C2D_TextBufResize(buf: C2D_TextBuf, maxGlyphs: size_t) -> C2D_TextBuf;
}
extern "C" {
    pub fn C2D_TextBufDelete(buf: C2D_TextBuf);
}
extern "C" {
    pub fn C2D_TextBufClear(buf: C2D_TextBuf);
}
extern "C" {
    pub fn C2D_TextBufGetNumGlyphs(buf: C2D_TextBuf) -> size_t;
}
extern "C" {
    pub fn C2D_TextParseLine(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn C2D_TextFontParseLine(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn C2D_TextParse(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn C2D_TextFontParse(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn C2D_TextOptimize(text: *const C2D_Text);
}
extern "C" {
    pub fn C2D_TextGetDimensions(
        text: *const C2D_Text,
        scaleX: f32,
        scaleY: f32,
        outWidth: *mut f32,
        outHeight: *mut f32,
    );
}
extern "C" {
    pub fn C2D_DrawText(
        text: *const C2D_Text,
        flags: u32_,
        x: f32,
        y: f32,
        z: f32,
        scaleX: f32,
        scaleY: f32,
        ...
    );
}
